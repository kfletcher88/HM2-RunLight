#!/usr/bin/perl  

## Version 2.00

## Introduction.

use strict; 
use warnings;

my $Arg_list = join " ", @ARGV;
if (@ARGV < 1 || $Arg_list =~ m/--help|-\?/) { print <<'USAGES' and exit; }

  This script is to update tables produced by HM_pathFinder_preparation.pl,
and to find paths that can be used to select represetative haplotypes 
from a diploid genome assembly.

  --help or no arguments - show this message, ignore undefined inputs

  --Species -   mandatory, to provide species names which are wanted to be
                processed
                NOTE THAT the species name should be given
                in ORDER, because the name comes first will be used
                as the target.
                Example: --Species bbev1a bbev1b
                In this script, both names refer to the same genome assembly,
                the name come first is used as the target genome, the second
                name is used as the query genome.
                  
  --pathFindingMode=<original|updated> - select runing mode
                ***original***, 
                to use orginal tables generated by pathFinder_preparation.pl
                to find the paths for haplotype selection and merging.
                This is the default behavoir.
                These original tables should be placed in 
                directory ./species0.specie1.result/, which include 3 files:
                hm.scaffolds,
                hm.sc_portions,
                hm.nodes.
                ***updated***, 
                to use updated or edited data
                Three files required:
                hm.scaffolds,
                hm.sc_portions(_edited/_updated),
                hm.nodes(_edited/_updated).
                One file optional:
                hm.assembly_errors(_edited/_updated).
                Note that you may want to save the manunally edited
                hm.assembly_errors as hm.assembly_errors_edited, because
                this script will overwrite hm.assembly_errors.
  --updatedPortions=<portions_file> - specify file for read,
                required for --pathFindingMode=updated
  --updatedNodes=<nodes_file> - specify file for read,
                required for --pathFindingMode=updated
  --updatedErrors=<errors_file> - specify file for read,
                optional for --pathFindingMode=updated                                            
  
  --scoreScheme=<ali|score> - choose alignment_length or alignment_score
                as the scoring system (default=score) 
  --filter=N - filter out aligned block low than N 
               (default=200000 for score, 2000 for ali)
  --escapeFilter=N - nodes that cover >N% of the scaffold length
               escapes filtering (invocated by --filter) (def=50)                           
               
  --breakingMode=N - mode to break a potential assembly mis-join (default=1),
               a mis-join is defined by the violation of long-term colinearity
               0=not perfomr the cutting
               1=break one of the two scaffolds, try to preserve contiguity
               2=break both scaffolds
  --misjoin_aliFilter=N - min-alignment score or length to detect a mis-join     
               (default=50000 for ali_length, 5000000 for ali_score)          
  --misjoin_overhangFilter=N - minimum length of the overhang required to
               determine a mis-join (default=50000)
               
  --NsLCsFilter=N - delete alignments consisting of mainly Ns and lowcases
               (default=90(%))
               
  --noSelfLoop - delete self loops before graph traversing (def=1)
  --noStrandConflict - delete strand conflicts before graph traversing (def=1)                           
               
  --verbose[=N] - print more information [0,1,2] (default=0)      
  --Force - force to overwrite existing result files
  --Delete - delete intermediate and temp files (no effect on logfiles)        
	
	Required files:
		~result/hm.scaffolds,
		~result/hm.nodes,
		~result/hm.sc_portions.	
	
  Output files include:
    ~result/hm.unpaired, 
    ~result/hm.new_scaffolds, 
    ~result/hm.assembly_errors.
		 
  For updating, additional output files are created:
    hm.nodes_updated
      (integrates manually-edited data),
    hm.sc_portions_updated
      (integrates manually-edited data from both
       hm.sc_portions and hm.assembly_errors). 
	 
USAGES

print "\n\n========== Start at "; system("date");
print "$0 $Arg_list\n\n";
my $timer = time();

#### set the output_field_separator to " " and autoflushing
$,=' ';
$|=1;

# special parameters
# Store species names and result directory name
my (@Species, $out_dir); 
unless ($Arg_list =~ m/--Species\s+([^-]*)/) {die "No --Species argument or species_names found!\n"; }
unless (@Species = $1 =~ m/(\w+)/g)  {die "No species names found!\n"; }
$out_dir = "$Species[0].$Species[1].result";
print "Species included: ", @Species, "\n";

#### parse the arguments  
my %para = ("--pathFindingMode" => "original",  "--Force" => 0, "--Delete" => 0, "--verbose" => 0, "--minLen" => 1.25,
						"--scoreScheme" => "score", "--filter" => 0, "--escapeFilter" => 50,
						"--updatedPortions" => "", "--updatedNodes"    => "", "--updatedErrors"    => "",
						"--breakingMode" =>1, "--misjoin_overhangFilter"=>50000, "--misjoin_aliFilter"=>0,
						"--NsLCsFilter" =>90, "--noSelfLoop" =>1, "--noStrandConflict" =>1 );

# parameters with values
while($Arg_list =~ m/(--\S+)=(\S+)/g){ 
	if(exists($para{$1})){
		$para{$1}=$2;
	}else{
		die "Parameter $1 is unknown!\n";
	}
}

# parameters of toggle type
while($Arg_list =~ m/(--\w+)\s+-/g){ 
	if(exists($para{$1})){
		$para{$1}=1;
	}else{
		die "Parameter $1 is unknown!\n";
	}
}
while($Arg_list =~ m/(--\w+)\s*\z/g){ 
	if(exists($para{$1})){
		$para{$1}=1;
	}else{
		die "Parameter $1 is unknown!\n";
	}
}

#### set score scheme
my $scheme=$para{"--scoreScheme"};
die "--scoreScheme=$scheme is not legal.\n" if $scheme ne "ali" and $scheme ne "score";
my $filter= $scheme eq "score" ? 200000 : 2000; 
$filter= $para{"--filter"}!=0 ? $para{"--filter"} : $filter;
print "Set the scoring scheme to $scheme, and set the filter score/ali_len to $filter.\n";
$scheme= $scheme eq "ali" ? 10 : 9;

#### set mis-join breaking mode and filters
$para{'--breakingMode'}=int $para{'--breakingMode'};
$para{'--breakingMode'}=0 if $para{'--breakingMode'}<0 or $para{'--breakingMode'}>2;
if($para{'--misjoin_aliFilter'} == 0){
	$para{'--misjoin_aliFilter'} = $scheme==9 ? 5000000 : 50000;
}
print "Set the breakingMode to $para{'--breakingMode'},\n";
print "and set the misjoin_aliFilter to $para{'--misjoin_aliFilter'},\n";
print "and set the misjoin_overhangFilter to $para{'--misjoin_overhangFilter'}.\n";

#### set the over-write flag and other flags
#print "--noSelf is set to  $para{'--noSelf'} !\n";
print "--noSelfLoop is set to  $para{'--noSelfLoop'} !\n";
print "--noStrandConflict is set to $para{'--noStrandConflict'} !\n";
print "Set to OVER-WRITING mode!\n" if $para{"--Force"}>0;
print "Set to DELETING mode!\n" if $para{"--Delete"}>0;
print "Set to VERBOSE mode (",$para{"--verbose"},")!\n" if $para{"--verbose"}>0;

#########################################
#### scaffold info
# @tsc_ids, stores the name and the size of a (target) scaffold, ordered by size, descendent
#		$tsc_ids[tsc_id]->[name, size, start_of_node_id, end_of_node_id, is_incorporated(1-as tsc, -1-as qsc]
# @qsc_ids, stores the name and the size of a (query) scaffold, ordered by size, descendent
#		$qsc_ids[qsc_id]->[name, size, start_of_node_by_query_id, end_of_node_by_query_id, is_incorporated]
# %sc_names, store the name(hash key) and the id (hash value) of a scaffold
#
# note that scaffold ids of all data structures use the same system !
my (@tsc_ids, @qsc_ids, %sc_names);

#########################################
#### read the filtered.rbest.net file and produce nodes' data structure
# @nodes, store each pairwise alignment(net) block, ordered by target position
# 	$nodes[.]->[0..16]=[0:node_id,
#                       1:tsc_id, 2:strand(1,-1), 3:tstart, 4:tlen, 
#	                      5:qsc_id, 6:strand(1,-1), 7:qstart, 8:qlen, 
#                       9:ali_score, 10:ali_len,   11:predecessor,  12:successor, 
#                      13:tsc_portion_ref,      14:qsc_portion_ref,
#											 15:tsc_direction_predecessor, 16:tsc_direction_successor,
#											 17:qsc_direction_predecessor, 18:tsc_direction_successor,
#                      19:deletion_visit_flag
#											 ( +1=visited during perfect path pair, +2=visited in mis-join breaking, +4=visit in path finding, 3=both 1 and 2, 5=1 and 4, 6=2 and 4, 7=1,2,4
#                      ( >=0:no deletion,  -1: manual deletion, -2:score filtered, -3:lowcases , -4: deletion due too many Ns_lowcases,
#                       -5:strand switich, -6:self_loop, -7:loop, -8:switch_loop -9:deleted_during_anti_mirror, 
#                      -10:, -11:trivial node (stringent), -12:trivial node(adj_node_count=0), 
#											 -13:trival node(count=1), -14:trivial node(count=2), -15:trivial node(count=3),-16:trivial node(count=4),-17:self-self nontrivial nodes
#                      20:chain_id, 21:net_id (internal), 22:mirror_or_not(0:no, 1:yes)
#                      23:[new_scaffold_id],
#                      24:[order_in_new_scaffold],
#											 25:tsc_N_count, 26:tsc_lowcase_count, 27:qsc_N_count, 28:qsc_lowcase_count,
#                      29:[manual_deletion]
# @nodes_by_target, pointers to nodes, ordered by target, asc, the synonym of @nodes
# @nodes_by_query, pointers to nodes, ordered by query position, asc
# @nodes_by_score, pointers to nodes, ordered by score, desc 
my (@nodes, @nodes_by_target, @nodes_by_query, @nodes_by_score);
my (@npointers); #pointer to the mirror nodes
my (@score_origin, @ali_len_origin); # save up the original score/ali_len

#########################################
#### portion info		
# @tsc_portions, store each portions and the node which the portion belonged to, ordered by start position
#		$tsc_portions[tsc_id]->[portion_id]->
#			[0:portion_id, 1:tsc_id, 2:start_position, 3:len, 4:node_id, 5:node_status, 6:portion_status, 7:is_incorporated, 8:broken_due_to_assembly_errors, 9:manual_breaking] 
# @qsc_portions, store each portions and the node which the portion belonged to, ordered by start position
#		$qsc_portions[qsc_id]->[portion_id]->
#			[0:portion_id, 1:qsc_id, 2:start_position, 3:len, 4:node_id, 5:node_status, 6:portion_status, 7:is_incorporated, 8:broken_due_to_assembly_errors, 9:manual_breaking] 
#			#4:node_id=-1 means not a node portion
#			#4:node_id=id point to a node
#			#5:node_status=3 means both 1 and 2
#			#5:node_status=2 means the node has been finally visited
#			#5:node_status=1 means the node has been visited by perfect path finding
#			#5:node_status=0 means the node has not been visited
#			#5:node_status<0 means the node has been deleted(-1..-6), 
#                      ( -1: manual deletion, -2:score filtered, -3: trivial node, -4: embeded node,
#                       -5:strand switich,-6:self_loop,   -7:loop,           -8: switch_loop)
#			#6:portion_status=1 regular
#			#6:portion_status=0 means the portion have no alignment hit
#			#6:portion_status<0 means the portion have been marked as holding a breakpoint
#					#(-1:strand switch, -2:self_loop, -3:loop, -4:switch_loop,  
#					  -5:branch(reserved/not broken side), -6:branch(broken side), -7:manual breaking, -8:broken_due_to_assembly_errors)
my (@tsc_portions, @qsc_portions);

#########################################
#### new scaffold info
# @new_scaffolds store each new scaffolds
# $new_scaffolds[ns_id]->[0:is_active, 1:start_node, 2:start_sc_id, 3:start_sc_strand, 4:start_portion_id,
#                                      5:end_node,   6:end_sc_id,   7:end_sc_strand,   8:end_portion_id,
#                         9:node_count, 10:len, 11:new_scaffold_id, 12:target_or_query_of_start_node, 13:targe_or_query_of_end_node]
# @new_portions store each portion of new scaffolds
# $new_portions[new_scaffold_id]->[sub_id][np_id]->
#                        [0:new_scaffold_id, 1:selected_portion(1 or 2),
#                         2:sc_id, 3:start, 4:end, 5:strand, # portion 1,
#                         6:sc_id, 7:start, 8:end, 9:strand  # portion 2,
#													10:connection_flag, 11:score_for_node_portions, 12:tsc_Ns, 13:tsc_LCs, 14:qsc_Ns, 15:qsc_LCs ] 
my (@new_scaffolds,@new_portions, @new_scaffolds_by_length);

#########################################
#### assembly mis-joins
# @mis_joins[id]=[0:node_id, 1:alignment_len, 2:ali_len_or_score, 3:terminal(5/3), 
#									4:tsc_name, 5:tsc_size, 	6:tsc_strand, 7:ali_start_of_tsc,  8:ali_end_of_tsc,  9:joining_point_of_tsc, 10:overhang_len_of_tsc,
#								 11:tsc_name, 5:tsc_size,  12:qsc_strand,13:ali_start_of_qsc, 14:ali_end_of_qsc, 15:joining_point_of_qsc, 16:overhang_len_of_qsc,
#                17:*tsc_breakpoint, 18:*tsc_breakpoint, 19:*breakpoint_setting ]  
my @mis_joins;

sub load_data($$$);
sub load_data_updated($$$$);

if($para{"--pathFindingMode"} eq "original"){
	load_data("$out_dir/hm.scaffolds","$out_dir/hm.nodes","$out_dir/hm.sc_portions");
}elsif($para{"--pathFindingMode"} eq "updated"){
	print "--updatedNodes is set to $para{'--updatedNodes'}.\n";
	print "--updatedPortions is set to $para{'--updatedPortions'}.\n";
	if(not -f $para{"--updatedNodes"}){ print "Required updatedNotes file, ",$para{"--updatedNodes"}," is not found.\n"; die; }
	if(not -f $para{"--updatedPortions"}){ print "Required updatedPortions file, ",$para{"--updatedPortions"}," is not found.\n"; die; }
	if(not exists $para{"--updatedErrors"}){
		load_data_updated("$out_dir/hm.scaffolds",$para{"--updatedNodes"},$para{"--updatedPortions"},"");
	}else{
		print "--updatedErrors is set to $para{'--updatedErrors'}.\n"; 
		if(not -f $para{"--updatedErrors"}){ print "Optional updatedErrors file, ",$para{"--updatedErrors"}," is not found.\n"; die; }
		load_data_updated("$out_dir/hm.scaffolds",$para{"--updatedNodes"},$para{"--updatedPortions"},$para{"--updatedErrors"});	
	}
}else{
	die "The parameter --pathFindingMode=<..> is not legal!\n";
}

#########################################
#### finding path now 	

sub perfect_path_extending();
sub four_adjacent_nodes($);
sub loop_scanning();
sub path_extending();
sub path_terminal_extending();
sub new_scaffold_traversing();
sub extra_statistics_of_nodes();
sub output_new_scaffolds();
sub output_potential_assembly_error();
sub output_unpaired_portions();

my ($low_scored_node_count, $loop_count, $switch_count,$ns_lowcases_count, 
		$trivial_count, $branch_count, $misjoin_deletion_count)=(0,0,0,0,0,0,0); #running messages
my ($escape_count,$self_self_count,$strand_switch_count, $self_loop_count)=(0,0,0,0);		
my (%np,%np_extra);
my ($having_loop, $node_deletion_during_extending);
my @node_stats=(0,0,0,0,0);
my ($raw_haplome_size, $raw_haplome_scaffold_N50_size,$raw_haplome_scaffold_N50_number)=(0,0,0);
my ($raw_size_of_unpaired_scaffolds, $raw_size_of_unpaired_scaffold_portions)=(0,0);

####
#### to delete self-self nontrivial nodes
##  --noSelf - delete self-self nontrivial alignments/nodes (def=0)
$para{'--noSelf'}=1;
if($para{'--noSelf'}>0){
	for(my $i=0;$i<scalar(@nodes);$i++){
		next if $nodes[$i]->[19]<0; 
		if($nodes[$i]->[1]==$nodes[$i]->[5]){
			$nodes[$i]->[19] = -17;
			$tsc_portions[$nodes[$i]->[1]]->[$nodes[$i]->[13]][5] = -17;
			$qsc_portions[$nodes[$i]->[5]]->[$nodes[$i]->[14]][5] = -17;
	
			$npointers[$nodes[$i]->[0]]->[19]=-17;
			$tsc_portions[$npointers[$nodes[$i]->[0]]->[1]]->[$npointers[$nodes[$i]->[0]]->[13]][5]=-17;
			$qsc_portions[$npointers[$nodes[$i]->[0]]->[5]]->[$npointers[$nodes[$i]->[0]]->[14]][5]=-17;			
			$self_self_count+=2;
		}			
	}
}
print "Deleted $self_self_count self-self nontrivial nodes (-17).\n"; 

####
#### to delete the low-scored nodes
for(my $i=0;$i<scalar(@nodes);$i++){
	next if $nodes[$i]->[19]<0;
	if($nodes[$i]->[$scheme]<$filter){
		if($nodes[$i]->[4]/$tsc_ids[$nodes[$i]->[1]]->[1]>$para{'--escapeFilter'}/100 
				or $nodes[$i]->[8]/$tsc_ids[$nodes[$i]->[5]]->[1]>$para{'--escapeFilter'}/100){
			$escape_count++;
			next;
		}		
		$nodes[$i]->[19] = -2;
		$tsc_portions[$nodes[$i]->[1]]->[$nodes[$i]->[13]][5] = -2;
		$qsc_portions[$nodes[$i]->[5]]->[$nodes[$i]->[14]][5] = -2;

		$npointers[$nodes[$i]->[0]]->[19]=-2;
		$tsc_portions[$npointers[$nodes[$i]->[0]]->[1]]->[$npointers[$nodes[$i]->[0]]->[13]][5]=-2;
		$qsc_portions[$npointers[$nodes[$i]->[0]]->[5]]->[$npointers[$nodes[$i]->[0]]->[14]][5]=-2;			
		$low_scored_node_count+=2;
	}			
}
print "Deleted $low_scored_node_count low-scored nodes (-2) (minimum score/ali_len = ",$filter,").\n"; 
print "$escape_count nodes escape low-score filtering (threshold = $para{'--escapeFilter'} %).\n"; 

####
#### to delete the nodes are trivial
if($para{'--minLen'}>0){
	my ($tsc_len, $qsc_len, $len_t5, $len_t3, $len_q5, $len_q3, $ttlen);
	for(my $i=0;$i<scalar(@nodes);$i++){
		next if $nodes[$i]->[19]<0;
		($tsc_len, $qsc_len) = ( $tsc_ids[$nodes[$i]->[1]]->[1], $qsc_ids[$nodes[$i]->[5]]->[1] );
		($len_t5, $len_t3) = ( $nodes[$i]->[3], $tsc_len-$nodes[$i]->[4]-$nodes[$i]->[3] );
		($len_q5, $len_q3) = $nodes[$i]->[6]>0 ? 
														( $nodes[$i]->[7], $qsc_len-$nodes[$i]->[8]-$nodes[$i]->[7] ) 
															: ( $qsc_len-$nodes[$i]->[7]-$nodes[$i]->[8], $nodes[$i]->[7] );
		$ttlen = $nodes[$i]->[4]>$nodes[$i]->[8] ? $nodes[$i]->[8] : $nodes[$i]->[4];
		if( $len_t5>$ttlen*4*$para{'--minLen'} and $len_t3>$ttlen*4*$para{'--minLen'}
					and $len_q5>$ttlen*4*$para{'--minLen'} and $len_q3>$ttlen*4*$para{'--minLen'} ){ # score setting
			$nodes[$i]->[19] = -11;
			$tsc_portions[$nodes[$i]->[1]]->[$nodes[$i]->[13]][5] = -11;
			$qsc_portions[$nodes[$i]->[5]]->[$nodes[$i]->[14]][5] = -11;
				
			$npointers[$nodes[$i]->[0]]->[19]=-11;
			$tsc_portions[$npointers[$nodes[$i]->[0]]->[1]]->[$npointers[$nodes[$i]->[0]]->[13]][5]=-11;
			$qsc_portions[$npointers[$nodes[$i]->[0]]->[5]]->[$npointers[$nodes[$i]->[0]]->[14]][5]=-11;				
			$trivial_count+=2;
		}
	}
}
print "Deleted $trivial_count trivial nodes (stringent) (--minLen*4 = ",$para{'--minLen'}*4,") (=-11).\n"; 

####
#### to delete the nodes mainly consisting of Ns and lowcases
for(my $i=0;$i<scalar(@nodes);$i++){
	next if $nodes[$i]->[19]<0;
	if( ($nodes[$i]->[25]+$nodes[$i]->[26])/$nodes[$i]->[4] > $para{'--NsLCsFilter'}/100 
			 and  ($nodes[$i]->[27]+$nodes[$i]->[28])/$nodes[$i]->[8] > $para{'--NsLCsFilter'}/100 ){
		$nodes[$i]->[19] = -3;
		$tsc_portions[$nodes[$i]->[1]]->[$nodes[$i]->[13]][5] = -3;
		$qsc_portions[$nodes[$i]->[5]]->[$nodes[$i]->[14]][5] = -3;
		
		$npointers[$nodes[$i]->[0]]->[19]=-3;
		$tsc_portions[$npointers[$nodes[$i]->[0]]->[1]]->[$npointers[$nodes[$i]->[0]]->[13]][5]=-3;
		$qsc_portions[$npointers[$nodes[$i]->[0]]->[5]]->[$npointers[$nodes[$i]->[0]]->[14]][5]=-3;		
		$ns_lowcases_count+=2;
	}			
}
print "Deleted $ns_lowcases_count nodes mainly consisting of Ns and lowcases (-3) (>$para{'--NsLCsFilter'}%).\n"; 

####
#### chain up the node from the same target-query pair and delete self-loops and strand-conflict
perfect_path_extending();
#since the addup-score have been updated in subroutine perfect_path_extending, 
#re-ordering of @nodes_by_score is needed 
@nodes_by_score = sort { $b->[$scheme] <=> $a->[$scheme] or $a->[21] <=> $b->[21] } @nodes;

####
#### cut the mis-joined scaffolds
%np_extra=( 't53_len'=>-1, 'q53_len'=>-1,    't53_max_len'=>-1, 'q53_max_len'=>-1, 't53_raw_len'=>-1, 'q53_raw_len'=>-1,
					  't5_len'=>-1,  't5_max_len'=>-1, 't5_switch'=>-1,'t5_raw_len'=>-1,
					  't3_len'=>-1,  't3_max_len'=>-1, 't3_switch'=>-1,'t3_raw_len'=>-1,
					  'q5_len'=>-1,  'q5_max_len'=>-1, 'q5_switch'=>-1,'q5_raw_len'=>-1,
					  'q3_len'=>-1,  'q3_max_len'=>-1, 'q3_switch'=>-1,'q3_raw_len'=>-1 );					  
for(my $i=0;$i<scalar(@nodes_by_score);$i++){
	next if $nodes_by_score[$i]->[19]<0 or $nodes_by_score[$i]->[19]>1;
	
	## to find correct values for $node_t5/t3/q5/q3 and $score_t5/t3/q5/q3
	%np=('is_visited'=>$nodes_by_score[$i]->[0], 'start_node'=>$nodes_by_score[$i]->[0], 'end_node'=>$nodes_by_score[$i]->[0], 
	     'tsc_id'=>$nodes_by_score[$i]->[1], 'qsc_id'=>$nodes_by_score[$i]->[5],
	     'tsc_strand'=>$nodes_by_score[$i]->[2], 'qsc_strand'=>$nodes_by_score[$i]->[6], 
			 't5'=>-1, 't5_score'=>0, 't5_strand'=>$nodes_by_score[$i]->[2], 
			 't3'=>-1, 't3_score'=>0, 't3_strand'=>$nodes_by_score[$i]->[2], 
			 'q5'=>-1, 'q5_score'=>0, 'q5_strand'=>$nodes_by_score[$i]->[6], 
			 'q3'=>-1, 'q3_score'=>0, 'q3_strand'=>$nodes_by_score[$i]->[6] );
	four_adjacent_nodes($nodes_by_score[$i]->[0]);
	extra_statistics_of_nodes();

	# to store potential mis-joins data
	my ($t5,$t3)=($nodes[$np{'start_node'}],$nodes[$np{'end_node'}]);
	my ($qstart,$qend,$qjoin,$qoverhang, $qsign)= $t3->[6]>0 ? 
																								 ($t5->[7],$t3->[7]+$t3->[8],$t3->[7]+$t3->[8],$np_extra{'q3_raw_len'}, '+') 
																							 : ($t3->[7],$t5->[7]+$t5->[8],$t3->[7],$np_extra{'q3_raw_len'}, '-');
	push @mis_joins,[$t3->[0],$t3->[3]+$t3->[4]-$t5->[3],$t3->[$scheme],3,   
									 $tsc_ids[$t3->[1]]->[0],$tsc_ids[$t3->[1]]->[1],'+',$t5->[3],$t3->[3]+$t3->[4],$t3->[3]+$t3->[4],$np_extra{'t3_raw_len'},
							     $qsc_ids[$t3->[5]]->[0],$qsc_ids[$t3->[5]]->[1],$qsign,$qstart,$qend,$qjoin,$qoverhang,   -1,-1,0];
	($qstart,$qend,$qjoin,$qoverhang, $qsign)= $t5->[6]>0 ? 
																							($t5->[7],$t3->[7]+$t3->[8],$t5->[7],$np_extra{'q5_raw_len'}, '+') 
																						: ($t3->[7],$t5->[7]+$t5->[8],$t5->[7]+$t5->[8],$np_extra{'q5_raw_len'}, '-');
	push @mis_joins,[$t5->[0],$t3->[3]+$t3->[4]-$t5->[3],$t5->[$scheme],5,   
									 $tsc_ids[$t5->[1]]->[0],$tsc_ids[$t5->[1]]->[1],'+',$t5->[3],$t3->[3]+$t3->[4],$t5->[3],$np_extra{'t5_raw_len'},    
									 $qsc_ids[$t5->[5]]->[0],$qsc_ids[$t5->[5]]->[1],$qsign,$qstart,$qend,$qjoin,$qoverhang,   -1,-1,0];	
									 
	# breaking mis-joins
	if($para{'--breakingMode'}>0 and $nodes[$np{'start_node'}]->[$scheme]>=$para{'--misjoin_aliFilter'}){
	
		if($para{'--breakingMode'}==2){
			if($np_extra{'t5_len'}>=$para{'--misjoin_overhangFilter'} and $np_extra{'q5_len'}>=$para{'--misjoin_overhangFilter'} ){
				$tsc_portions[$np{'tsc_id'}]->[$nodes[$np{'start_node'}]->[13]-1][6]=-8;
				$qsc_portions[$np{'qsc_id'}]->[$nodes[$np{'start_node'}]->[14]-$np{'qsc_strand'}][6]=-8;
				$misjoin_deletion_count+=2;
			}
			if($np_extra{'t3_len'}>=$para{'--misjoin_overhangFilter'} and $np_extra{'q3_len'}>=$para{'--misjoin_overhangFilter'} ){
				$tsc_portions[$np{'tsc_id'}]->[$nodes[$np{'end_node'}]->[13]+1][6]=-8;
				$qsc_portions[$np{'qsc_id'}]->[$nodes[$np{'end_node'}]->[14]+$np{'qsc_strand'}][6]=-8;
				$misjoin_deletion_count+=2;
			}		
		}elsif($para{'--breakingMode'}==1){
			my ($t1,$t2);
			if($np_extra{'t5_len'}>=$para{'--misjoin_overhangFilter'} and $np_extra{'q5_len'}>=$para{'--misjoin_overhangFilter'}){
				$t1= $np_extra{'t5_len'}<$np_extra{'q5_len'} ? $np_extra{'t5_len'}/$np_extra{'q5_len'} : $np_extra{'q5_len'}/$np_extra{'t5_len'};
				$t2= ($np_extra{'t3_len'}==0 and $np_extra{'q3_len'}==0) ? 1 :
						 $np_extra{'t3_len'}<$np_extra{'q3_len'} ? $np_extra{'t3_len'}/$np_extra{'q3_len'} : $np_extra{'q3_len'}/$np_extra{'t3_len'};
				if($t1>=0.8 and $t2<=0.2){ # guessing
					if($np_extra{'t3_len'}<$np_extra{'q3_len'}){
						$tsc_portions[$np{'tsc_id'}]->[$nodes[$np{'start_node'}]->[13]-1][6]=-8;
					}else{
						$qsc_portions[$np{'qsc_id'}]->[$nodes[$np{'start_node'}]->[14]-$np{'qsc_strand'}][6]=-8;
					}
				}elsif($np_extra{'t5_len'}<$np_extra{'q5_len'} or ($np_extra{'t5_len'}==$np_extra{'q5_len'} and $np{'tsc_id'}<$np{'qsc_id'})){
					$tsc_portions[$np{'tsc_id'}]->[$nodes[$np{'start_node'}]->[13]-1][6]=-8;
				}else{
					$qsc_portions[$np{'qsc_id'}]->[$nodes[$np{'start_node'}]->[14]-$np{'qsc_strand'}][6]=-8;
				}
				$misjoin_deletion_count+=1;
			}
			if($np_extra{'t3_len'}>=$para{'--misjoin_overhangFilter'} and $np_extra{'q3_len'}>=$para{'--misjoin_overhangFilter'}){
				$t1= $np_extra{'t3_len'}<$np_extra{'q3_len'} ? $np_extra{'t3_len'}/$np_extra{'q3_len'} : $np_extra{'q3_len'}/$np_extra{'t3_len'};
				$t2= ($np_extra{'t5_len'}==0 and $np_extra{'q5_len'}==0) ? 1 :
						 $np_extra{'t5_len'}<$np_extra{'q5_len'} ? $np_extra{'t5_len'}/$np_extra{'q5_len'} : $np_extra{'q5_len'}/$np_extra{'t5_len'};
				if($t1>=0.8 and $t2<=0.2){ # guessing
					if($np_extra{'t5_len'}<$np_extra{'q5_len'}){
						$tsc_portions[$np{'tsc_id'}]->[$nodes[$np{'end_node'}]->[13]+1][6]=-8;
					}else{
						$qsc_portions[$np{'qsc_id'}]->[$nodes[$np{'end_node'}]->[14]+$np{'qsc_strand'}][6]=-8;
					}			
				}elsif($np_extra{'t3_len'}<$np_extra{'q3_len'} or ($np_extra{'t3_len'}==$np_extra{'q3_len'} and $np{'tsc_id'}<$np{'qsc_id'})){
					$tsc_portions[$np{'tsc_id'}]->[$nodes[$np{'end_node'}]->[13]+1][6]=-8;
				}else{
					$qsc_portions[$np{'qsc_id'}]->[$nodes[$np{'end_node'}]->[14]+$np{'qsc_strand'}][6]=-8;
				}
				$misjoin_deletion_count+=1;			
			}
		}
	
	}
	
	## finish a successful visit of a node for mis-join checking
	for(my $j=$np{'start_node'};$j<=$np{'end_node'};$j++){
		if($nodes[$j]->[19]>=0){
			$nodes[$j]->[19] += 2; 
		}
	}	
}
## set back the visiting flag to 0 or 1
for(my $i=0;$i<scalar(@nodes);$i++){
	if($nodes[$i]->[19]>1){
		$nodes[$i]->[19] -= 2;
	}
}
print "Break $misjoin_deletion_count assembly mis-joining points (-8).\n";

####
#### delete trivial nodes after breaking the mis-joins using recalculated length
if($para{'--minLen'}>0){
	%np_extra=( 't53_len'=>-1, 'q53_len'=>-1,    't53_max_len'=>-1, 'q53_max_len'=>-1, 't53_raw_len'=>-1, 'q53_raw_len'=>-1,
						  't5_len'=>-1,  't5_max_len'=>-1, 't5_switch'=>-1,'t5_raw_len'=>-1,
						  't3_len'=>-1,  't3_max_len'=>-1, 't3_switch'=>-1,'t3_raw_len'=>-1,
						  'q5_len'=>-1,  'q5_max_len'=>-1, 'q5_switch'=>-1,'q5_raw_len'=>-1,
						  'q3_len'=>-1,  'q3_max_len'=>-1, 'q3_switch'=>-1,'q3_raw_len'=>-1 );					  
	
	for(my $i=0;$i<scalar(@nodes_by_score);$i++){
		next if $nodes_by_score[$i]->[19]<0 or $nodes_by_score[$i]->[19]>1;
		
		## to find correct values for $node_t5/t3/q5/q3 and $score_t5/t3/q5/q3
		%np=('is_visited'=>$nodes_by_score[$i]->[0], 'start_node'=>$nodes_by_score[$i]->[0], 'end_node'=>$nodes_by_score[$i]->[0], 
		     'tsc_id'=>$nodes_by_score[$i]->[1], 'qsc_id'=>$nodes_by_score[$i]->[5],
		     'tsc_strand'=>$nodes_by_score[$i]->[2], 'qsc_strand'=>$nodes_by_score[$i]->[6], 
				 't5'=>-1, 't5_score'=>0, 't5_strand'=>$nodes_by_score[$i]->[2], 
				 't3'=>-1, 't3_score'=>0, 't3_strand'=>$nodes_by_score[$i]->[2], 
				 'q5'=>-1, 'q5_score'=>0, 'q5_strand'=>$nodes_by_score[$i]->[6], 
				 'q3'=>-1, 'q3_score'=>0, 'q3_strand'=>$nodes_by_score[$i]->[6] );
		
		four_adjacent_nodes($nodes_by_score[$i]->[0]);
		extra_statistics_of_nodes();
	
		# delete trivial nodes (less strigent)
		my $min_len = $np_extra{'t53_raw_len'}-$np_extra{'t5_raw_len'}-$np_extra{'t3_raw_len'} 
										< $np_extra{'q53_raw_len'}-$np_extra{'q5_raw_len'}-$np_extra{'q3_raw_len'} ? 
											$np_extra{'t53_raw_len'}-$np_extra{'t5_raw_len'}-$np_extra{'t3_raw_len'} 
											: $np_extra{'q53_raw_len'}-$np_extra{'q5_raw_len'}-$np_extra{'q3_raw_len'};
		if($min_len*2*$para{'--minLen'}<$np_extra{'t5_len'} and $min_len*2*$para{'--minLen'}<$np_extra{'t3_len'} 
				and $min_len*2*$para{'--minLen'}<$np_extra{'q5_len'} and $min_len*2*$para{'--minLen'}<$np_extra{'q3_len'}){
			for(my $j=$np{'start_node'};$j<=$np{'end_node'};$j++){
				if($nodes[$j]->[19]>=0){
					$nodes[$j]->[19] = -11;
					$nodes[$j]->[11] = -1;
					$nodes[$j]->[12] = -1;
					$tsc_portions[$nodes[$j]->[1]]->[$nodes[$j]->[13]][5] = -11;
					$qsc_portions[$nodes[$j]->[5]]->[$nodes[$j]->[14]][5] = -11;

					$npointers[$nodes[$j]->[0]]->[19]=-11;
					$npointers[$nodes[$j]->[0]]->[11]=-1;
					$npointers[$nodes[$j]->[0]]->[12]=-1;								
					$tsc_portions[$npointers[$nodes[$j]->[0]]->[1]]->[$npointers[$nodes[$j]->[0]]->[13]][5]=-11;
					$qsc_portions[$npointers[$nodes[$j]->[0]]->[5]]->[$npointers[$nodes[$j]->[0]]->[14]][5]=-11;				
					$trivial_count+=2;
				}
			}
		}									 
	}
}
print "Deleted $trivial_count trivial nodes (less stringent) (--minLen*2 = ",$para{'--minLen'}*2,") (=-11).\n";

####
#### linearize the graph
%np_extra=( 't53_len'=>-1, 'q53_len'=>-1,    't53_max_len'=>-1, 'q53_max_len'=>-1, 't53_raw_len'=>-1, 'q53_raw_len'=>-1,
					  't5_len'=>-1,  't5_max_len'=>-1, 't5_switch'=>-1,'t5_raw_len'=>-1,
					  't3_len'=>-1,  't3_max_len'=>-1, 't3_switch'=>-1,'t3_raw_len'=>-1,
					  'q5_len'=>-1,  'q5_max_len'=>-1, 'q5_switch'=>-1,'q5_raw_len'=>-1,
					  'q3_len'=>-1,  'q3_max_len'=>-1, 'q3_switch'=>-1,'q3_raw_len'=>-1 );					  
for(my $i=0;$i<scalar(@nodes_by_score);$i++){
	next if $nodes_by_score[$i]->[19]<0 or $nodes_by_score[$i]->[19]>1;
	
	## to find correct values for $node_t5/t3/q5/q3 and $score_t5/t3/q5/q3
	%np=('is_visited'=>$nodes_by_score[$i]->[0], 'start_node'=>$nodes_by_score[$i]->[0], 'end_node'=>$nodes_by_score[$i]->[0], 
	     'tsc_id'=>$nodes_by_score[$i]->[1], 'qsc_id'=>$nodes_by_score[$i]->[5],
	     'tsc_strand'=>$nodes_by_score[$i]->[2], 'qsc_strand'=>$nodes_by_score[$i]->[6], 
			 't5'=>-1, 't5_score'=>0, 't5_strand'=>$nodes_by_score[$i]->[2], 
			 't3'=>-1, 't3_score'=>0, 't3_strand'=>$nodes_by_score[$i]->[2], 
			 'q5'=>-1, 'q5_score'=>0, 'q5_strand'=>$nodes_by_score[$i]->[6], 
			 'q3'=>-1, 'q3_score'=>0, 'q3_strand'=>$nodes_by_score[$i]->[6] );
	four_adjacent_nodes($nodes_by_score[$i]->[0]);
	
	## scan for loop and setting the having_loop flag
	# having_loop=0: means no loop; 
	# having_loop=1: means having loop, and the node that cause the loop will be deleted;
	# loop_count and switch_count are also recorded in this step. 
	$having_loop = loop_scanning(); 
	next if $having_loop>0;
	
	## extend the path, solve the branching problem, and record $branch_count, too
	$node_deletion_during_extending=path_extending();
	next if $node_deletion_during_extending==0;
	
	## finish a successful addition of a node into paths
	for(my $j=$np{'start_node'};$j<=$np{'end_node'};$j++){
		if($nodes[$j]->[19]>=0){
			$nodes[$j]->[19] += 2; 
			$tsc_portions[$nodes[$j]->[1]]->[$nodes[$j]->[13]][5] += 2;
			$qsc_portions[$nodes[$j]->[5]]->[$nodes[$j]->[14]][5] += 2;
		}
	}
}

####
#### finalizing
	
## printing messages
print "Total self_loops are $self_loop_count (-6).\n";
print "Total strand switchs are $strand_switch_count nodes (-5).\n";
print "Deleted $loop_count loops (=node count, -7).\n";
print "Deleted $switch_count switch loops (=node count, -8).\n";
print "Deleted totally $trivial_count trivial nodes (relax) (--minLen*1 = ",$para{'--minLen'}*1,") (<=-11).\n";
print "Nodes with no adjacent nodes: $node_stats[0] .\n";
print "Nodes with 1  adjacent nodes: $node_stats[1] .\n";
print "Nodes with 2  adjacent nodes: $node_stats[2] .\n";
print "Nodes with 3  adjacent nodes: $node_stats[3] .\n";
print "Nodes with 4  adjacent nodes: $node_stats[4] .\n";

my $node_count_temp=0;
for(my $i=0;$i<scalar(@nodes);$i++){
	$node_count_temp++ if $nodes[$i]->[19]>0;
}
print "There are ",$node_count_temp," informative nodes left .\n";
print "Break $branch_count branches (including mirror paths).\n";

## Set the breakpoint status on the terminals of each path/new_scaffold (a path can be converted to a new_scaffold)
## store paths/new_scaffolds
path_terminal_extending();
print "Finished path_terminal_extending!\n";

## select the final path, output the new_scaffold data
new_scaffold_traversing();
print "Finished new_scaffold traversing!\n";

## output new_scaffold files ($out_dir/hm.new_scaffolds)
output_new_scaffolds();
print "Finished ouput new_scaffolds to $out_dir/hm.new_scaffolds!\n";

## output potential mis-joins of the assembly
output_potential_assembly_error();
print "Finished ouput potential assembly errors (mis_joins) to $out_dir/hm.assembly_errors!\n";

## output unpaired portions of scaffolds
output_unpaired_portions();
print "Finished output unpaired scaffolds and scaffold portions.\n";

## output statistics
print "\n";
print "The raw haplome size is $raw_haplome_size bp;\n";
print "the raw haplome scaffold N50 number is $raw_haplome_scaffold_N50_number;\n";
print "the raw haplome scaffold N50 size is $raw_haplome_scaffold_N50_size bp;\n";
print "the raw size of unpaired scaffolds is $raw_size_of_unpaired_scaffolds bp;\n";
print "the raw size of unpaired scaffold portions is $raw_size_of_unpaired_scaffold_portions bp.\n"; 

#########################################
if($para{"--Delete"}==1){
}

print "\n\n========== Time used = ", time()-$timer, " seconds or ", (time()-$timer)/3600, " hours.\n\n";

######################################### subroutines #########################################

#########################################
#
#########################################
sub load_data($$$){
	
	my ($sc_file,$node_file,$sc_portion_file) = @_;
	
	####
	open(my $scaffoldFH, "<$sc_file") or die "Can not open $sc_file!\n";
	while(<$scaffoldFH>){
		next if m/^#|^\s/;
		chomp;
		my $tt = [ split /\t/ ];
		my $temp = shift @$tt;
		$tsc_ids[$temp] = $tt;
		$tt = [ split /\t/ ];
		$temp = shift @$tt;
		$qsc_ids[$temp] = $tt;
	}
	close $scaffoldFH;
	for(my $i=0;$i<scalar(@tsc_ids);$i++) {
		$sc_names{"$tsc_ids[$i]->[0]"} = $i;
	}
	
	####
	open(my $nodeFH,"<$node_file") or die "Can not open $node_file!\n";
	while(<$nodeFH>){
		next if m/^#|^\s/;
		chomp;
		my $tt = [ split /\t/ ];
		shift @$tt; #delete tsc_name
		shift @$tt; #delete qsc_name
		splice @$tt,10,1;
		splice @$tt,5,1;
		$nodes[$tt->[0]] = $tt;
	}
	close $nodeFH;
	
	####
	for(my $i=0;$i<scalar(@nodes);$i++){
		($score_origin[$i],$ali_len_origin[$i])=( $nodes[$i]->[9], $nodes[$i]->[10] );
	}
	
	#### save pointers to mirror nodes, use @nodes_by_score as temp
	@nodes_by_score = sort { $a->[21] <=> $b->[21] } @nodes;
	for(my $i=0;$i<scalar(@nodes_by_score);$i+=2){
		$npointers[$nodes_by_score[$i]->[0]]=$nodes_by_score[$i+1];
		$npointers[$nodes_by_score[$i+1]->[0]]=$nodes_by_score[$i];
	}
	
	####
	@nodes_by_score = sort { $b->[$scheme] <=> $a->[$scheme] or $a->[21] <=> $b->[21] } @nodes;
	
	#### produce @nodes_by_target
	@nodes_by_target = sort { $a->[1] <=> $b->[1] or $a->[3] <=> $b->[3] } @nodes;
	my $tsc_pt = $nodes_by_target[0]->[1]; # the first one
	$tsc_ids[$tsc_pt]->[2] = 0;
	for(my $i=1;$i<scalar(@nodes_by_target);$i++){ #the ones between the first and the last
		if($tsc_pt != $nodes_by_target[$i]->[1]){
			$tsc_ids[$nodes_by_target[$i-1]->[1]]->[3] = $i-1;
			$tsc_ids[$nodes_by_target[$i]->[1]]->[2] = $i;
			$tsc_pt = $nodes_by_target[$i]->[1];
		}
	}
	$tsc_pt = $nodes_by_target[scalar(@nodes_by_target)-1]->[1]; # the last one
	$tsc_ids[$tsc_pt]->[3] = scalar(@nodes_by_target)-1;

	#### produce @nodes_by_query
	@nodes_by_query = sort { $a->[5] <=> $b->[5] or $a->[7] <=> $b->[7] } @nodes;
	my $qsc_pt = $nodes_by_query[0]->[5]; # the first one
	$qsc_ids[$qsc_pt]->[2] = 0;
	for(my $i=1;$i<scalar(@nodes_by_query);$i++){ #the ones between the first and the last
		if($qsc_pt != $nodes_by_query[$i]->[5]){
			$qsc_ids[$nodes_by_query[$i-1]->[5]]->[3] = $i-1;
			$qsc_ids[$nodes_by_query[$i]->[5]]->[2] = $i;
			$qsc_pt = $nodes_by_query[$i]->[5];
		}
	}
	$qsc_pt = $nodes_by_query[scalar(@nodes_by_query)-1]->[5]; # the last one
	$qsc_ids[$qsc_pt]->[3] = scalar(@nodes_by_query)-1;
	
	####
	open(my $sc_portionFH,"<$sc_portion_file") or die "Can not open $sc_portion_file!\n";
	while(<$sc_portionFH>){
		next if m/^#|^\s/;
		chomp;
		my $tt = [ split /\t/ ];
		shift @$tt; #delete sc_name
		$tsc_portions[$tt->[1]]->[$tt->[0]] = $tt;
		my $ttt; @$ttt = @$tt;
		$qsc_portions[$tt->[1]]->[$tt->[0]] = $ttt;		
	}
	close $sc_portionFH;
	
	# correcting the qsc_portion's node_id
	foreach my $tt (@nodes){
		my ($qsc_id, $portion_id, $node_id) = ($tt->[5], $tt->[14], $tt->[0]);
		$qsc_portions[$qsc_id]->[$portion_id][4]=$node_id;
	}
	
	print "Finished reading the original data files.\n";
}

#########################################
#
#########################################
sub load_data_updated($$$$){
	
	my ($sc_file,$node_file,$sc_portion_file,$error_file) = @_;
	my $temp;
	my $tmp_txt;
		
	#### read in scaffold table
	open(my $scaffoldFH, "<$sc_file") or die "Can not open $sc_file!\n";
	while(<$scaffoldFH>){
		next if m/^#|^\s/;
		chomp;
		my $tt = [ split /\t/ ];
		$temp = shift @$tt;
		$tsc_ids[$temp] = $tt;
		$tt = [ split /\t/ ];
		$temp = shift @$tt;
		$qsc_ids[$temp] = $tt;
	}
	close $scaffoldFH;
	for(my $i=0;$i<scalar(@tsc_ids);$i++) {
		$sc_names{"$tsc_ids[$i]->[0]"} = $i;
	}
	
	####
	#### read in node table
	$tmp_txt='';
	open(my $nodeFH,"<$node_file") or die "Can not open $node_file!\n";
	while(<$nodeFH>){
		if(m/^#|^\s/){ $tmp_txt.=$_; next; }
		chomp;
		my $tt = [ split /\t/ ];
		shift @$tt; #delete tsc_name
		shift @$tt; #delete qsc_name
		splice @$tt,10,1;
		splice @$tt,5,1;
		$nodes[$tt->[0]] = $tt;
	}
	close $nodeFH;
	
	####
	for(my $i=0;$i<scalar(@nodes);$i++){
		($score_origin[$i],$ali_len_origin[$i])=( $nodes[$i]->[9], $nodes[$i]->[10] );
	}
	
	#### save pointers to mirror nodes, and updated the manual_deletion status to mirror node, use @nodes_by_score as temp
	@nodes_by_score = sort { $a->[21] <=> $b->[21] } @nodes;
	for(my $i=0;$i<scalar(@nodes_by_score);$i+=2){
		#
		$npointers[$nodes_by_score[$i]->[0]]=$nodes_by_score[$i+1];
		$npointers[$nodes_by_score[$i+1]->[0]]=$nodes_by_score[$i];
		#
		$npointers[$nodes_by_score[$i]->[0]]->[29]  =1 if $nodes_by_score[$i]->[29]  ==1;
		$npointers[$nodes_by_score[$i+1]->[0]]->[29]=1 if $nodes_by_score[$i+1]->[29]==1;
	}
	
	####
	if(-f "$out_dir/hm.nodes_updated"){
		unlink "$out_dir/hm.nodes_updated.bak";
		rename "$out_dir/hm.nodes_updated","$out_dir/hm.nodes_updated.bak";
	}
	print "Output the updated node (alignment block) infomation to $out_dir/hm.nodes_updated.\n";
	open($nodeFH,">$out_dir/hm.nodes_updated") or die "Can not create $out_dir/hm.nodes_updated! \n";
	print $nodeFH $tmp_txt;
	for(my $i=0;$i<scalar(@nodes);$i++){
		$,="\t";
		print $nodeFH $tsc_ids[$nodes[$i]->[1]]->[0],$qsc_ids[$nodes[$i]->[5]]->[0],@{$nodes[$i]}[0 .. 4],$nodes[$i]->[3]+$nodes[$i]->[4],@{$nodes[$i]}[5 .. 8],$nodes[$i]->[7]+$nodes[$i]->[8],@{$nodes[$i]}[9 .. 29];
		print $nodeFH "\n";
		$,=' ';
	}
	close $nodeFH;
	
	####
	for(my $i=0;$i<scalar(@nodes);$i++){
		$nodes[$i]->[19]=-1 if $nodes[$i]->[29]==1;
	}			
	
	#### produce @nodes_by_score
	@nodes_by_score = sort { $b->[$scheme] <=> $a->[$scheme] or $a->[21] <=> $b->[21] } @nodes;
	
	#### produce @nodes_by_target
	@nodes_by_target = sort { $a->[1] <=> $b->[1] or $a->[3] <=> $b->[3] } @nodes;
	my $tsc_pt = $nodes_by_target[0]->[1]; # the first one
	$tsc_ids[$tsc_pt]->[2] = 0;
	for(my $i=1;$i<scalar(@nodes_by_target);$i++){ #the ones between the first and the last
		if($tsc_pt != $nodes_by_target[$i]->[1]){
			$tsc_ids[$nodes_by_target[$i-1]->[1]]->[3] = $i-1;
			$tsc_ids[$nodes_by_target[$i]->[1]]->[2] = $i;
			$tsc_pt = $nodes_by_target[$i]->[1];
		}
	}
	$tsc_pt = $nodes_by_target[scalar(@nodes_by_target)-1]->[1]; # the last one
	$tsc_ids[$tsc_pt]->[3] = scalar(@nodes_by_target)-1;

	#### produce @nodes_by_query
	@nodes_by_query = sort { $a->[5] <=> $b->[5] or $a->[7] <=> $b->[7] } @nodes;
	my $qsc_pt = $nodes_by_query[0]->[5]; # the first one
	$qsc_ids[$qsc_pt]->[2] = 0;
	for(my $i=1;$i<scalar(@nodes_by_query);$i++){ #the ones between the first and the last
		if($qsc_pt != $nodes_by_query[$i]->[5]){
			$qsc_ids[$nodes_by_query[$i-1]->[5]]->[3] = $i-1;
			$qsc_ids[$nodes_by_query[$i]->[5]]->[2] = $i;
			$qsc_pt = $nodes_by_query[$i]->[5];
		}
	}
	$qsc_pt = $nodes_by_query[scalar(@nodes_by_query)-1]->[5]; # the last one
	$qsc_ids[$qsc_pt]->[3] = scalar(@nodes_by_query)-1;
	
	####
	#### read in portion table
	open(my $sc_portionFH,"<$sc_portion_file") or die "Can not open $sc_portion_file!\n";
	$tmp_txt='';
	while(<$sc_portionFH>){
		if(m/^#|^\s/){ $tmp_txt.=$_; next; }
		chomp;
		my $tt = [ split /\t/ ];
		shift @$tt; #delete sc_name
		if($tt->[4]>-1 and ($tt->[8]==1 or $tt->[9]==1)){
			die "A node portion can not be a breakpoint (hm.sc_portions); node_id is $tt->[4]; scaffold_id is $tt->[1]; portion_id is $tt->[0] .\n";
		}
		$tsc_portions[$tt->[1]]->[$tt->[0]] = $tt;
		my $ttt; @$ttt = @$tt;
		$qsc_portions[$tt->[1]]->[$tt->[0]] = $ttt;		
	}
	close $sc_portionFH;
	
	# correcting the qsc_portion's node_id
	foreach my $tt (@nodes){
		my ($qsc_id, $portion_id, $node_id) = ($tt->[5], $tt->[14], $tt->[0]);
		$qsc_portions[$qsc_id]->[$portion_id][4]=$node_id;
	}
	
	####
	#### read in file hm.assembly_errors_edited and update file hm.sc_portions with data from hm.assembly_errors_edit
	my %breakpoints;
	###
	open(my $errFH, "<$error_file") or die "Can not read $error_file !\n";
	my $tt;
	while(<$errFH>){
		next if m/^#|^\s/;
		$tt = [ split /\t/ ];
		$tt->[3]  = $tt->[3]==5 ? -1 : 1;
		$tt->[6]  = $tt->[6] eq '+' ? 1 : -1;
		$tt->[13] = $tt->[13] eq '+' ?  1 : -1;
		if($tt->[20]==1){
			$breakpoints{$tt->[0].'_'.$sc_names{$tt->[4]}}  = $tt->[3]*$tt->[6];
		}elsif($tt->[20]==2){
			$breakpoints{$tt->[0].'_'.$sc_names{$tt->[11]}} = $tt->[3]*$tt->[13];
		}elsif($tt->[20]==3){
			$breakpoints{$tt->[0].'_'.$sc_names{$tt->[4]}}  = $tt->[3]*$tt->[6];
			$breakpoints{$tt->[0].'_'.$sc_names{$tt->[11]}} = $tt->[3]*$tt->[13];
		}
	}
	close $errFH;
		
	###
	foreach my $tt (@nodes){
		if(exists($breakpoints{$tt->[0].'_'.$tt->[1]})){
			$tsc_portions[$tt->[1]]->[$tt->[13]+$breakpoints{$tt->[0].'_'.$tt->[1]}][8]=1;
			$qsc_portions[$tt->[1]]->[$tt->[13]+$breakpoints{$tt->[0].'_'.$tt->[1]}][8]=1;				
		}
		if(exists($breakpoints{$tt->[0].'_'.$tt->[5]})){
			$tsc_portions[$tt->[5]]->[$tt->[14]+$breakpoints{$tt->[0].'_'.$tt->[5]}][8]=1;
			$qsc_portions[$tt->[5]]->[$tt->[14]+$breakpoints{$tt->[0].'_'.$tt->[5]}][8]=1;				
		}			
	}
	
	#### 
	if(-f "$out_dir/hm.sc_portions_updated"){
		unlink "$out_dir/hm.sc_portions_updated.bak";
		rename "$out_dir/hm.sc_portions_updated","$out_dir/hm.sc_portions_updated.bak";
	}
	print "Output the updated scaffold portion infomation to $out_dir/hm.sc_portions_updated.\n";
	open(my $tsc_portionFH,">$out_dir/hm.sc_portions_updated") or die "Can not create $out_dir/hm.sc_portions_updated! \n";
	print $tsc_portionFH $tmp_txt;
	$,="\t";
	for(my $i=0;$i<scalar(@tsc_portions);$i++){
		my $portion_count=scalar(@{$tsc_portions[$i]});
		my $portion_ref; 
		for(my $j=0;$j<$portion_count;$j++){
			$portion_ref = $tsc_portions[$i]->[$j];
			print $tsc_portionFH $tsc_ids[$portion_ref->[1]]->[0],@{$portion_ref};
			print $tsc_portionFH "\n";
		}
	}
	$,=' ';
	close $tsc_portionFH;	
	
	####
	foreach my $tt (@nodes){
		if($tt->[19]<0){
			$tsc_portions[$tt->[1]]->[$tt->[13]][5]=$tt->[19];
			$qsc_portions[$tt->[5]]->[$tt->[14]][5]=$tt->[19];
		}
	}
	for(my $i=0;$i<scalar(@tsc_portions);$i++){
		my $portion_count=scalar(@{$tsc_portions[$i]});
		for(my $j=0;$j<$portion_count;$j++){
			$tsc_portions[$i]->[$j][6]=-7 if $tsc_portions[$i]->[$j][9]==1;
			$tsc_portions[$i]->[$j][6]=-8 if $tsc_portions[$i]->[$j][8]==1;
			$qsc_portions[$i]->[$j][6]=-7 if $qsc_portions[$i]->[$j][9]==1;
			$qsc_portions[$i]->[$j][6]=-8 if $qsc_portions[$i]->[$j][8]==1;			
		}
	}
	
	print "Finished reading the updated data files.\n";
}

#########################################
#
#########################################
sub perfect_path_extending(){

	my ($temp, $temp1);
	my ($tsc_id, $qsc_id, $tsc_por, $qsc_por);
	my @queue; # store node from the same tsc-qsc pair
	my ($cp, $np, $finish_flag, $join_flag, $insertion_flag, $qcount, $status); #pointers to @queue
	my ($adjacent_pair_count)=(0);
	my ($pp,$pn);	
	my (%tsc2qsc,$tq);

	for(my $i=0;$i<scalar(@nodes);$i++){
		next if $nodes[$i]->[19]<0;
		if(exists $tsc2qsc{$nodes[$i]->[1].'_'.$nodes[$i]->[5]}){
			$tsc2qsc{$nodes[$i]->[1].'_'.$nodes[$i]->[5]}++;
		}else{
			$tsc2qsc{$nodes[$i]->[1].'_'.$nodes[$i]->[5]}=1;
		}
	}
	
	####
	#### to delete self loops and strand conflicts before graph traversing
	if($para{'--noSelfLoop'}>0 or $para{'--noStrandConflict'}>0){
		foreach $tq (keys %tsc2qsc){
			
			next unless $tsc2qsc{$tq}>1;
			$tq =~ m/(\d+)_(\d+)/;
			($tsc_id,$qsc_id)=($1,$2);
			
			($tsc_por,$qsc_por)=($tsc_portions[$tsc_id],$qsc_portions[$qsc_id]);
	
			@queue=();		
			for(my $j=0;$j<scalar(@$tsc_por);$j++){
				$temp = $tsc_por->[$j][4]; #node_id
				next if $temp<0 or $nodes[$temp]->[19]<0;
				if($nodes[$temp]->[1]==$tsc_id and $nodes[$temp]->[5]==$qsc_id){
					push @queue,$nodes[$temp];
				}
			}		
			$qcount=scalar(@queue);
			
			# delete node that cause self_loop
			if($qcount>1 and $para{'--noSelfLoop'}>0){
				@queue = sort { $b->[$scheme] <=> $a->[$scheme] } @queue;
				for(my $j=0;$j<scalar(@queue)-1;$j++){
					next if $queue[$j]->[19]<0;
					#$pp = $queue[$j]->[1] == $queue[$j]->[5] ? 1 : $queue[$j]->[6]; # if there are self-self alignments
					$pp = $queue[$j]->[6];
					for(my $k=$j+1;$k<scalar(@queue);$k++){
						next if $queue[$k]->[19]<0;
						if(	($queue[$j]->[3]+$queue[$j]->[4]/2-$queue[$k]->[3]-$queue[$k]->[4]/2)
									*($queue[$j]->[7]+$queue[$j]->[8]/2-$queue[$k]->[7]-$queue[$k]->[8]/2)*$pp<0	){
							# self_loop detected
							$qcount--;
							#
							$queue[$k]->[19]=-6;
							$tsc_por->[$queue[$k]->[13]][5]=-6;
							$qsc_por->[$queue[$k]->[14]][5]=-6;
							$tsc2qsc{$tsc_id.'_'.$qsc_id}--;
							#
							$npointers[$queue[$k]->[0]]->[19]=-6;
							$tsc_portions[$npointers[$queue[$k]->[0]]->[1]]->[$npointers[$queue[$k]->[0]]->[13]][5]=-6;
							$qsc_portions[$npointers[$queue[$k]->[0]]->[5]]->[$npointers[$queue[$k]->[0]]->[14]][5]=-6;
							$tsc2qsc{$qsc_id.'_'.$tsc_id}--;
							$self_loop_count+=2; # running message
							last;
						}
					}
				}
			}
			
			# delete node that cause $strand conflicts
			if($qcount>1 and $para{'--noStrandConflict'}>0){
				
				@queue=();
				($pp, $pn)=(0,0);
				for(my $j=0;$j<scalar(@$tsc_por);$j++){
					$temp = $tsc_por->[$j][4]; #node_id
					next if $temp<0 or $nodes[$temp]->[19]<0;
					if($nodes[$temp]->[1]==$tsc_id and $nodes[$temp]->[5]==$qsc_id){
						push @queue,$nodes[$temp];
						if($nodes[$temp]->[6]>0){
							$pp+=$nodes[$temp]->[$scheme];
						}else{
							$pn+=$nodes[$temp]->[$scheme];
						}	
					}
				}
				$pp = $pp>=$pn ? 1 : -1; #1:++, -1:+-
				
				for(my $j=0;$j<scalar(@queue);$j++){
					next if $queue[$j]->[6] == $pp;
					$queue[$j]->[19]=-5;
					$tsc_por->[$queue[$j]->[13]][5]=-5;
					$qsc_por->[$queue[$j]->[14]][5]=-5;
					$tsc2qsc{$tsc_id.'_'.$qsc_id}--;
					#
					$npointers[$queue[$j]->[0]]->[19]=-5;
					$tsc_portions[$npointers[$queue[$j]->[0]]->[1]]->[$npointers[$queue[$j]->[0]]->[13]][5]=-5;
					$qsc_portions[$npointers[$queue[$j]->[0]]->[5]]->[$npointers[$queue[$j]->[0]]->[14]][5]=-5;
					$tsc2qsc{$qsc_id.'_'.$tsc_id}--;
					$strand_switch_count+=2; # running message	
				}							
			}			
		}
	}		

	####
	#### chain adjacent nodes
	foreach $tq (keys %tsc2qsc){
		
		next unless $tsc2qsc{$tq}>1;
		$tq =~ m/(\d+)_(\d+)/;
		($tsc_id,$qsc_id)=($1,$2);
		
		($tsc_por,$qsc_por)=($tsc_portions[$tsc_id],$qsc_portions[$qsc_id]);
		
		@queue=();
		for(my $j=0;$j<scalar(@$tsc_por);$j++){
			$temp = $tsc_por->[$j][4]; #node_id
			next if $temp<0 or $nodes[$temp]->[19]<0;
			if($nodes[$temp]->[1]==$tsc_id and $nodes[$temp]->[5]==$qsc_id){
				push @queue,$nodes[$temp];
			}
		}

		($cp,$np)=(0,0);
		$qcount=scalar(@queue);
		$finish_flag=0;
		$join_flag=0;
		$insertion_flag=0;
		$status='';
		while($finish_flag==0){
			
			$np++;
			if($np>=$qcount){ 
				$join_flag=1;
			}
			
			if($join_flag==0){
				## testing if tandem or loop
				#$pp = $queue[$cp]->[1]==$queue[$cp]->[5] ? 1 : $queue[$cp]->[6]; # if there are self-self alignments
				$pp = $queue[$cp]->[6];
				if(	($queue[$cp]->[3]+$queue[$cp]->[4]/2-$queue[$np]->[3]-$queue[$np]->[4]/2)
							*($queue[$cp]->[7]+$queue[$cp]->[8]/2-$queue[$np]->[7]-$queue[$np]->[8]/2)*$pp>0
							and $queue[$cp]->[6]==$queue[$np]->[6]	){
					$status='tandem';
				}else{
					$status='loop_or_strand_conflict';
				}

				## testing if there is any insertion or not
				if($status eq 'tandem'){
					for(my $i=$queue[$np-1]->[13]+1;$i!=$queue[$np]->[13];$i++){
						if($tsc_por->[$i][6]<-5 or ($tsc_por->[$i][4]>-1 and $tsc_por->[$i][5]>=0)){
							$insertion_flag=1;
							last;
						}
					}
					for(my $i=$queue[$np-1]->[14]+$pp;$i!=$queue[$np]->[14];$i+=$pp){
						if($qsc_por->[$i][6]<-5 or ($qsc_por->[$i][4]>-1 and $qsc_por->[$i][5]>=0)){
							$insertion_flag=1;
							last;
						}
					}
				}
				
				## action
				if($insertion_flag==0 and $status eq 'tandem'){
					next;											
				}else{
					$join_flag=1; $insertion_flag=0;	
				}				
			}
			
			if($join_flag==1){
				if($np-$cp>=2){
					($temp,$temp1)=(0,0);
					for(my $l=$cp;$l<=$np-1;$l++){
						$temp+=$queue[$l]->[9];
						$temp1+=$queue[$l]->[10];
					}
					for(my $l=$cp;$l<$np-1;$l++){
						# chaining
						$queue[$l]->[12]   = $queue[$l+1]->[0];
						$queue[$l]->[9]  = $temp;
						$queue[$l]->[10] = $temp1;
						# set the is_visited flag
						$queue[$l]->[19]=1;
						$tsc_portions[$queue[$l]->[1]]->[$queue[$l]->[13]][5] = 1;
						$qsc_portions[$queue[$l]->[5]]->[$queue[$l]->[14]][5] = 1;					
	
						$queue[$l+1]->[11] = $queue[$l]->[0];
						$queue[$l+1]->[9]  = $temp;
						$queue[$l+1]->[10] = $temp1;
						# set the is_visited flag
						$queue[$l+1]->[19]=1;
						$tsc_portions[$queue[$l+1]->[1]]->[$queue[$l+1]->[13]][5] = 1;
						$qsc_portions[$queue[$l+1]->[5]]->[$queue[$l+1]->[14]][5] = 1;
											
						$adjacent_pair_count++; # running message
					}
				}
				$cp=$np;
				$finish_flag=1 if $cp>=$qcount;
				$join_flag=0;
			}		
		}
	}
		
	print "Finished seeking self_loops in perfect_path_finding ($self_loop_count, -6) \n";
	print "and chaining adjacent nodes ($adjacent_pair_count) from same target query scaffolds!\n";
	print "Also delete $strand_switch_count nodes (-5) with strand conflict with the mainstream.\n";
}

#########################################
#
#########################################
sub four_adjacent_nodes($){
	
	my $temp = shift;
	my $is_found;
	my $node_id = $temp;
	my $node = $nodes[$node_id];
	my ($tstart,$tend) = ($node->[3], $node->[3]+$node->[4]);
	my ($qstart,$qend) = ($node->[7], $node->[7]+$node->[8]);
	
	if($node->[19]==1){
		$np{'is_visited'}=1;
		$temp=$node;
		while($temp->[12]>-1){
			$temp=$nodes[$temp->[12]];
		}
		$np{'end_node'}=$temp->[0];	
		$temp=$node;
		while($temp->[11]>-1){
			$temp=$nodes[$temp->[11]];
		}
		$np{'start_node'}=$temp->[0];			
	}
	$np{'tsc_id'}=$node->[1]; $np{'qsc_id'}=$node->[5]; $np{'tsc_strand'}=$node->[2]; $np{'qsc_strand'}=$node->[6];
	
	#### to find correct values for $node_t5/t3/q5/q3 and $score_t5/t3/q5/q3

	#################### node_t5
	$is_found=0;
	$node=$nodes[$np{'start_node'}];
	for($temp=$node->[13]-1;$temp>=0;$temp--){
		if($tsc_portions[$np{'tsc_id'}]->[$temp][4]>-1 and $tsc_portions[$np{'tsc_id'}]->[$temp][5]>1){
			$temp=$tsc_portions[$np{'tsc_id'}]->[$temp][4];
			$is_found=1;
			last;
		}elsif($tsc_portions[$np{'tsc_id'}]->[$temp][4]<0 and $tsc_portions[$np{'tsc_id'}]->[$temp][6]<-5){
			$temp=-1;
			last;
		}
	}
	if($is_found>0){
		$np{'t5'}=$temp;
		$np{'t5_strand'}=$nodes[$temp]->[2];
		$np{'t5_score'} = $nodes[$temp]->[$scheme];
	}else{
		$np{'t5'}=-1;
		$np{'t5_strand'}=$node->[2];
		$np{'t5_score'} = 0;	
	}
	
	#################### node_t3
	$is_found=0;
	$node=$nodes[$np{'end_node'}];
	for($temp=$node->[13]+1;$temp<scalar(@{$tsc_portions[$np{'tsc_id'}]});$temp++){
		if($tsc_portions[$np{'tsc_id'}]->[$temp][4]>-1 and $tsc_portions[$np{'tsc_id'}]->[$temp][5]>1){
			$temp=$tsc_portions[$np{'tsc_id'}]->[$temp][4];
			$is_found=1;
			last;
		}elsif($tsc_portions[$np{'tsc_id'}]->[$temp][4]<0 and $tsc_portions[$np{'tsc_id'}]->[$temp][6]<-5){
			$temp=-1;
			last;
		}
	}
	#$temp=-1 if $temp>=scalar(@{$tsc_portions[$np{'tsc_id'}]});
	if($is_found>0){
		$np{'t3'}=$temp;
		$np{'t3_strand'}=$nodes[$temp]->[2];
		$np{'t3_score'} = $nodes[$temp]->[$scheme];
	}else{
		$np{'t3'}=-1;
		$np{'t3_strand'}=$node->[2];
		$np{'t3_score'} = 0;	
	} 
	
	#################### node_q5
	$is_found=0;
	$node=$nodes[$np{'start_node'}];
	for($temp=$node->[14]-1;$temp>=0;$temp--){
		if($qsc_portions[$np{'qsc_id'}]->[$temp][4]>-1 and $qsc_portions[$np{'qsc_id'}]->[$temp][5]>1){
			$temp=$qsc_portions[$np{'qsc_id'}]->[$temp][4];
			$is_found=1;
			last;
		}elsif($qsc_portions[$np{'qsc_id'}]->[$temp][4]<0 and $qsc_portions[$np{'qsc_id'}]->[$temp][6]<-5){
			$temp=-1;
			last;
		}
	}
	if($is_found>0){
		$np{'q5'}=$temp;
		$np{'q5_strand'}=$nodes[$temp]->[6];
		$np{'q5_score'} = $nodes[$temp]->[$scheme];
	}else{
		$np{'q5'}=-1;
		$np{'q5_strand'}=$node->[6];
		$np{'q5_score'} = 0;	
	}
	
	#################### node_q3
	$is_found=0;
	$node=$nodes[$np{'end_node'}];
	for($temp=$node->[14]+1;$temp<scalar(@{$qsc_portions[$np{'qsc_id'}]});$temp++){
		if($qsc_portions[$np{'qsc_id'}]->[$temp][4]>-1 and $qsc_portions[$np{'qsc_id'}]->[$temp][5]>1){
			$temp=$qsc_portions[$np{'qsc_id'}]->[$temp][4];
			$is_found=1;
			last;
		}elsif($qsc_portions[$np{'qsc_id'}]->[$temp][4]<0 and $qsc_portions[$np{'qsc_id'}]->[$temp][6]<-5){
			$temp=-1;
			last;
		}
	}
	#$temp=-1 if $temp>=scalar(@{$qsc_portions[$np{'qsc_id'}]});
	if($is_found>0){
		$np{'q3'}=$temp;
		$np{'q3_strand'}=$nodes[$temp]->[6];
		$np{'q3_score'} = $nodes[$temp]->[$scheme];
	}else{
		$np{'q3'}=-1;
		$np{'q3_strand'}=$node->[6];
		$np{'q3_score'} = 0;	
	} 		
}

#########################################
# bug fixing: perfect mirror solve the swith_loop problem
#########################################
sub loop_scanning(){

	my $temp;
	my $deletion_type=0; # self loop (-6), strand switch (-5), loop(-7), switch_loop(-8)
	my $direction; #
	my @queue;

	####################				self loops and strand conflicts				####################
	if(	($np{'t3'}==$np{'q5'} and $np{'t3'}!=-1 and $np{'qsc_strand'}==1) or ($np{'t5'}==$np{'q3'} and $np{'t5'}!=-1  and $np{'qsc_strand'}==1)	
			or ($np{'t3'}==$np{'q3'} and $np{'t3'}!=-1 and $np{'qsc_strand'}==-1) or ($np{'t5'}==$np{'q5'} and $np{'t5'}!=-1  and $np{'qsc_strand'}==-1)	){
		$deletion_type=-6; # self loop
		$self_loop_count+=2;
	}elsif(	($np{'t3'}==$np{'q3'} and $np{'t3'}!=-1 and $np{'qsc_strand'}==1 and $np{'tsc_strand'}*$np{'qsc_strand'}!=$nodes[$np{'t3'}]->[2]*$nodes[$np{'t3'}]->[6])
					or ($np{'t3'}==$np{'q5'} and $np{'t3'}!=-1 and $np{'qsc_strand'}==-1 and $np{'tsc_strand'}*$np{'qsc_strand'}!=$nodes[$np{'t3'}]->[2]*$nodes[$np{'t3'}]->[6])
					or ($np{'t5'}==$np{'q5'} and $np{'t5'}!=-1 and $np{'qsc_strand'}==1 and $np{'tsc_strand'}*$np{'qsc_strand'}!=$nodes[$np{'t5'}]->[2]*$nodes[$np{'t5'}]->[6])
					or ($np{'t5'}==$np{'q3'} and $np{'t5'}!=-1 and $np{'qsc_strand'}==-1 and $np{'tsc_strand'}*$np{'qsc_strand'}!=$nodes[$np{'t5'}]->[2]*$nodes[$np{'t5'}]->[6])	){
		$deletion_type=-5; # strand conflict
		$strand_switch_count+=2;
	}
	
	if($deletion_type<0){ 
		for(my $i=$np{'start_node'};$i<=$np{'end_node'};$i++){
			if($nodes[$i]->[19]>=0){
				$nodes[$i]->[19]=$deletion_type;
				$tsc_portions[$np{'tsc_id'}]->[$nodes[$i]->[13]]->[5]=$deletion_type;
				$qsc_portions[$np{'qsc_id'}]->[$nodes[$i]->[14]]->[5]=$deletion_type;
				
				#processing mirror nodes
				$npointers[$nodes[$i]->[0]]->[19]=$deletion_type;
				$tsc_portions[$npointers[$nodes[$i]->[0]]->[1]]->[$npointers[$nodes[$i]->[0]]->[13]][5]=$deletion_type;
				$qsc_portions[$npointers[$nodes[$i]->[0]]->[5]]->[$npointers[$nodes[$i]->[0]]->[14]][5]=$deletion_type;				
			}
		}
		return 1;
	}

	####################	other than self loops and strand conflicts	####################
	
	#################### target 3' direction
	$temp=$np{'t3'};
	$direction = $np{'t3_strand'} == 1 ? 12 : 11;
	while($temp>-1){
		push @queue,$nodes[$temp];
		$temp = $nodes[$temp]->[$direction];
	}
	
	#################### target 5' direction
	$temp=$np{'t5'};
	$direction = $np{'t5_strand'} == 1 ? 11 : 12;
	while($temp>-1){
		push @queue,$nodes[$temp];
		$temp = $nodes[$temp]->[$direction];
	}
	
	#################### query 3' direction
	$temp=$np{'q3'};
	if($temp!=$np{'t3'} and $temp!=$np{'t5'}){
		$direction = $np{'q3_strand'} == 1 ? 12 : 11;
		while($temp>-1){
			push @queue,$nodes[$temp];
			$temp = $nodes[$temp]->[$direction];
		}
	}
	
	#################### query 5' direction
	$temp=$np{'q5'};
	if($temp!=$np{'t5'} and $temp!=$np{'t3'}){	
		$direction = $np{'q5_strand'} == 1 ? 11 : 12;
		while($temp>-1){
			push @queue,$nodes[$temp];
			$temp = $nodes[$temp]->[$direction];
		}
	}
		
	#################### return and output the result
	@queue = sort { $a->[21] <=> $b->[21] or $a->[0] <=> $b->[0] } @queue;
	for(my $i=0;$i<scalar(@queue)-1;$i++){
		if($queue[$i]->[21]==$queue[$i+1]->[21]){
			if($queue[$i]->[0]==$queue[$i+1]->[0]){
				$deletion_type = -7;
				$loop_count+=2;
				last;
			}else{
				$deletion_type = -8;
				$switch_count+=2;
				last;	
			}		
		}
	}
	
	if($deletion_type<0){ 
		for(my $i=$np{'start_node'};$i<=$np{'end_node'};$i++){
			if($nodes[$i]->[19]>=0){
				$nodes[$i]->[19]=$deletion_type;
				$tsc_portions[$np{'tsc_id'}]->[$nodes[$i]->[13]]->[5]=$deletion_type;
				$qsc_portions[$np{'qsc_id'}]->[$nodes[$i]->[14]]->[5]=$deletion_type;
				
				#processing mirror nodes
				$npointers[$nodes[$i]->[0]]->[19]=$deletion_type;
				$tsc_portions[$npointers[$nodes[$i]->[0]]->[1]]->[$npointers[$nodes[$i]->[0]]->[13]][5]=$deletion_type;
				$qsc_portions[$npointers[$nodes[$i]->[0]]->[5]]->[$npointers[$nodes[$i]->[0]]->[14]][5]=$deletion_type;				
			}
		}
		return 2;
	}
	
	####################					no loops and strand switchs					####################
	return 0;
}

#########################################
#
#########################################
sub path_extending(){
	
	#### have to keep perfect mirrored processing !!!!

	my ($temp,$temp1);
	my ($deletion_flag,$min_len);
	my $adj;
	my $link_sc;
	my $direction;
	my (@tq53,@queue);
	my ($tsc_deletion_type, $qsc_deletion_type, $cut_side, $cur_node, $adj_node);
		
	my $node_count=0;
	$node_count++ if $np{'t5'}>-1;
	$node_count++ if $np{'t3'}>-1;
	$node_count++ if $np{'q5'}>-1;
	$node_count++ if $np{'q3'}>-1;

	#switch adjacent nodes to their right places
	if($np{'qsc_strand'}==-1){
		@np{'q5', 'q5_score', 'q5_strand', 'q3', 'q3_score', 'q3_strand'} = @np{'q3', 'q3_score', 'q3_strand', 'q5', 'q5_score', 'q5_strand'};
	}
	
	#switch adjacent nodes to their right strand
	foreach $adj (qw(t5 t3 q5 q3)){
		next if $np{$adj} < 0;
		$link_sc = ($adj eq 't5' or $adj eq 't3') ? 'tsc' : 'qsc';
		if($np{$adj.'_strand'} != $np{$link_sc.'_strand'}){
			$np{$adj.'_strand'}*=-1;
			$direction = ($adj eq 't5' or $adj eq 'q5') ? 12 : 11;
			# switching now
			$temp=$np{$adj};
			@queue=();
			push @queue,$temp;
			while($nodes[$temp]->[$direction]>-1){
				$temp=$nodes[$temp]->[$direction];
				push @queue,$temp;
			}
			foreach $temp (@queue){
				($nodes[$temp]->[2],$nodes[$temp]->[6],$nodes[$temp]->[11],$nodes[$temp]->[12])
					= ($nodes[$temp]->[2]*-1,$nodes[$temp]->[6]*-1,$nodes[$temp]->[12],$nodes[$temp]->[11]);
			}
		}			
	}
	
	#look for the extra statistics of four adjacent nodes
	#such as 5'/3' terminal length of the tsc/qsc, 5'/3' terminal length of the paths ...
	extra_statistics_of_nodes();
	
	############# case 0
	$deletion_flag=1;
	$temp =$np_extra{'t53_len'}-$np_extra{'t5_len'}-$np_extra{'t3_len'};
	$temp1=$np_extra{'q53_len'}-$np_extra{'q5_len'}-$np_extra{'q3_len'};
	$min_len = $temp>$temp1 ? $temp1 : $temp;
	foreach $temp (qw(t5 t3 q5 q3)){
		next if $np{$temp}>-1;
		$deletion_flag=0 if $np_extra{$temp.'_len'}<=$min_len*$para{'--minLen'};
	}
	if($deletion_flag>0){
		for(my $i=$np{'start_node'};$i<=$np{'end_node'};$i++){
			if($nodes[$i]->[19]>=0){
				$nodes[$i]->[19] = -12-$node_count;
				$tsc_portions[$nodes[$i]->[1]]->[$nodes[$i]->[13]][5] = -12-$node_count;
				$qsc_portions[$nodes[$i]->[5]]->[$nodes[$i]->[14]][5] = -12-$node_count;
				$trivial_count++;
				
				$npointers[$nodes[$i]->[0]]->[19] = -12-$node_count; 
				$tsc_portions[$npointers[$nodes[$i]->[0]]->[1]]->[$npointers[$nodes[$i]->[0]]->[13]][5] = -12-$node_count;
				$qsc_portions[$npointers[$nodes[$i]->[0]]->[5]]->[$npointers[$nodes[$i]->[0]]->[14]][5] = -12-$node_count;
				$trivial_count++;				
			}
		}
		return 0;		
	}
	
	####
	$node_stats[$node_count]++;		
	
	############# case 1
	if($node_count==0){
			return 1;
	}	

	############# case 2
	if($node_count==1){
		
		#setting
		$adj = $np{'t5'}>-1 ? 't5' : $np{'t3'}>-1 ? 't3' : $np{'q5'}>-1 ? 'q5' : 'q3';
		$link_sc = ($adj eq 't5' or $adj eq 't3') ? 'tsc': 'qsc';		
		
		#cutting and joining
		$tsc_deletion_type = $link_sc eq 'tsc' ?  -5 : -6;
		$qsc_deletion_type = $link_sc eq 'qsc' ?  -5 : -6;
		$cut_side = ($adj eq 't5' or $adj eq 'q5') ? -1 : 1;
		$cur_node = ($adj eq 't5' or $adj eq 'q5') ? $nodes[$np{'start_node'}] : $nodes[$np{'end_node'}];
		$adj_node = $nodes[$np{$adj}];
		
		$temp =$tsc_portions[$cur_node->[1]]->[$cur_node->[13]+$cut_side*$cur_node->[2]]; $temp->[6]  = $tsc_deletion_type if $tsc_deletion_type<-5;
		$temp1=$qsc_portions[$cur_node->[5]]->[$cur_node->[14]+$cut_side*$cur_node->[6]]; $temp1->[6] = $qsc_deletion_type if $qsc_deletion_type<-5;

		$temp =$tsc_portions[$adj_node->[1]]->[$adj_node->[13]-$cut_side*$adj_node->[2]]; $temp->[6]  = $tsc_deletion_type if $tsc_deletion_type<-5;
		$temp1=$qsc_portions[$adj_node->[5]]->[$adj_node->[14]-$cut_side*$adj_node->[6]]; $temp1->[6] = $qsc_deletion_type if $qsc_deletion_type<-5;
											  		
		if($cut_side==-1){
			$adj_node->[12]=$cur_node->[0]; $cur_node->[11]=$adj_node->[0];
		}else{
			$adj_node->[11]=$cur_node->[0]; $cur_node->[12]=$adj_node->[0];
		}

		# return
		$branch_count+=2;
		return 1;
	}
	
	############# case 3
	if($node_count==2 and ($np{'t5'}+$np{'t3'}==-2 or $np{'q5'}+$np{'q3'}==-2)){

		#setting
		if($np{'t5'}+$np{'t3'}!=-2){
			$link_sc = 'tsc'; @tq53 = qw(t5 t3);
		}else{
			$link_sc = 'qsc'; @tq53 = qw(q5 q3);
		}
		$tsc_deletion_type = $link_sc eq 'tsc' ?  -5 : -6;
		$qsc_deletion_type = $link_sc eq 'qsc' ?  -5 : -6;
					
		#cutting and joining
		foreach $adj (@tq53){
			$cut_side = ($adj eq 't5' or $adj eq 'q5') ? -1 : 1;
			$cur_node = ($adj eq 't5' or $adj eq 'q5') ? $nodes[$np{'start_node'}] : $nodes[$np{'end_node'}];
			$adj_node = $nodes[$np{$adj}];
		
			$temp =$tsc_portions[$cur_node->[1]]->[$cur_node->[13]+$cut_side*$cur_node->[2]]; $temp->[6]  = $tsc_deletion_type if $tsc_deletion_type<-5;
			$temp1=$qsc_portions[$cur_node->[5]]->[$cur_node->[14]+$cut_side*$cur_node->[6]]; $temp1->[6] = $qsc_deletion_type if $qsc_deletion_type<-5;
		
			if($cut_side==-1){
				$adj_node->[12]=$cur_node->[0]; $cur_node->[11]=$adj_node->[0];
			}else{
				$adj_node->[11]=$cur_node->[0]; $cur_node->[12]=$adj_node->[0];
			}	
		}
		
		#return
		$branch_count+=2;
		return 1;		
	}
	
	############# case 4
	if($node_count==2 and ($np{'t5'}+$np{'q5'}==-2 or $np{'t3'}+$np{'q3'}==-2)){

		#setting
		if($np{'t3'}+$np{'q3'}!=-2){
			if($np_extra{'t3_len'}>$np_extra{'q3_len'} or ($np_extra{'t3_len'}==$np_extra{'q3_len'} and $np{'tsc_id'}>$np{'qsc_id'}) ){
				$link_sc ='tsc'; @tq53 = qw(t3);
			}else{
				$link_sc ='qsc'; @tq53 = qw(q3);
			}
		}else{
			if($np_extra{'t5_len'}>$np_extra{'q5_len'} or ($np_extra{'t5_len'}==$np_extra{'q5_len'} and $np{'tsc_id'}>$np{'qsc_id'}) ){
				$link_sc ='tsc'; @tq53 = qw(t5);
			}else{
				$link_sc ='qsc'; @tq53 = qw(q5);
			}
		}
		$tsc_deletion_type = $link_sc eq 'tsc' ?  -5 : -6;
		$qsc_deletion_type = $link_sc eq 'qsc' ?  -5 : -6;
					
		#cutting and joining
		foreach $adj (@tq53){
			$cut_side = ($adj eq 't5' or $adj eq 'q5') ? -1 : 1;
			$cur_node = ($adj eq 't5' or $adj eq 'q5') ? $nodes[$np{'start_node'}] : $nodes[$np{'end_node'}];
			$adj_node = $nodes[$np{$adj}];
		
			$temp =$tsc_portions[$cur_node->[1]]->[$cur_node->[13]+$cut_side*$cur_node->[2]]; $temp->[6]  = $tsc_deletion_type if $tsc_deletion_type<-5;
			$temp1=$qsc_portions[$cur_node->[5]]->[$cur_node->[14]+$cut_side*$cur_node->[6]]; $temp1->[6] = $qsc_deletion_type if $qsc_deletion_type<-5;
 
			$temp =$tsc_portions[$adj_node->[1]]->[$adj_node->[13]-$cut_side*$adj_node->[2]]; $temp->[6]  = $tsc_deletion_type if $tsc_deletion_type<-5;
			$temp1=$qsc_portions[$adj_node->[5]]->[$adj_node->[14]-$cut_side*$adj_node->[6]]; $temp1->[6] = $qsc_deletion_type if $qsc_deletion_type<-5;
		
			if($cut_side==-1){
				$adj_node->[12]=$cur_node->[0]; $cur_node->[11]=$adj_node->[0];
			}else{
				$adj_node->[11]=$cur_node->[0]; $cur_node->[12]=$adj_node->[0];
			}			
		}
		
		#return
		$branch_count+=2;
		return 1;					
	}
	
	############# case 5
	if($node_count==2 and ($np{'t5'}+$np{'q3'}==-2 or $np{'t3'}+$np{'q5'}==-2)){

		#setting
		if($np{'t5'}+$np{'q3'}!=-2){
			@tq53 = qw(t5 q3);
		}else{
			@tq53 = qw(q5 t3);
		}
					
		#cutting and joining
		foreach $adj (@tq53){
			$tsc_deletion_type = ($adj eq 't5' or $adj eq 't3') ?  -5 : -6;
			$qsc_deletion_type = ($adj eq 'q5' or $adj eq 'q3') ?  -5 : -6;
			$cut_side = ($adj eq 't5' or $adj eq 'q5') ? -1 : 1;
			$cur_node = ($adj eq 't5' or $adj eq 'q5') ? $nodes[$np{'start_node'}] : $nodes[$np{'end_node'}];
			$adj_node = $nodes[$np{$adj}];
		
			$temp =$tsc_portions[$cur_node->[1]]->[$cur_node->[13]+$cut_side*$cur_node->[2]]; $temp->[6]  = $tsc_deletion_type if $tsc_deletion_type<-5;
			$temp1=$qsc_portions[$cur_node->[5]]->[$cur_node->[14]+$cut_side*$cur_node->[6]]; $temp1->[6] = $qsc_deletion_type if $qsc_deletion_type<-5;
 
			$temp =$tsc_portions[$adj_node->[1]]->[$adj_node->[13]-$cut_side*$adj_node->[2]]; $temp->[6]  = $tsc_deletion_type if $tsc_deletion_type<-5;
			$temp1=$qsc_portions[$adj_node->[5]]->[$adj_node->[14]-$cut_side*$adj_node->[6]]; $temp1->[6] = $qsc_deletion_type if $qsc_deletion_type<-5;
		
			if($cut_side==-1){
				$adj_node->[12]=$cur_node->[0]; $cur_node->[11]=$adj_node->[0];
			}else{
				$adj_node->[11]=$cur_node->[0]; $cur_node->[12]=$adj_node->[0];
			}			
		}
		
		#return
		$branch_count+=4;
		return 1;					
	}

	############# case 6
	if($node_count==3){

		#setting
		if($np{'t5'}>-1 and $np{'t3'}>-1){
			$link_sc = 'tsc'; @tq53 = qw(t5 t3);
		}else{
			$link_sc = 'qsc'; @tq53 = qw(q5 q3);
		}
		$tsc_deletion_type = $link_sc eq 'tsc' ?  -5 : -6;
		$qsc_deletion_type = $link_sc eq 'qsc' ?  -5 : -6;
					
		#cutting and joining
		foreach $adj (@tq53){
			$cut_side = ($adj eq 't5' or $adj eq 'q5') ? -1 : 1;
			$cur_node = ($adj eq 't5' or $adj eq 'q5') ? $nodes[$np{'start_node'}] : $nodes[$np{'end_node'}];
			$adj_node = $nodes[$np{$adj}];
		
			$temp =$tsc_portions[$cur_node->[1]]->[$cur_node->[13]+$cut_side*$cur_node->[2]]; $temp->[6]  = $tsc_deletion_type if $tsc_deletion_type<-5;
			$temp1=$qsc_portions[$cur_node->[5]]->[$cur_node->[14]+$cut_side*$cur_node->[6]]; $temp1->[6] = $qsc_deletion_type if $qsc_deletion_type<-5;
		
			if($cut_side==-1){
				$adj_node->[12]=$cur_node->[0]; $cur_node->[11]=$adj_node->[0];
			}else{
				$adj_node->[11]=$cur_node->[0]; $cur_node->[12]=$adj_node->[0];
			}			
		}
		
		#return
		$branch_count+=2;
		return 1;					
	}		
					
}

#########################################
#
#########################################
sub path_terminal_extending(){
	
	my ($temp,$temp1);
	my ($node,$sc);
	my ($tlen,$qlen);
	my $node_count;
	my (@begins, @ends);
	
	{ # remove break points from adjacent tandem nodes
		my ($ts, $qs); #strand sign
		my ($insertion_flag);
		for(my $i=0;$i<scalar(@nodes);$i++){
			##
			next if $nodes[$i]->[19]<0;
			$temp=$nodes[$i];
			next if $temp->[12]<0;
			$temp1=$nodes[$temp->[12]];
			next if $temp->[1] != $temp1->[1] or $temp->[2] != $temp1->[2] or $temp->[5] != $temp1->[5] or $temp->[6] != $temp1->[6];
			($ts,$qs)=($temp->[2],$temp->[6]);
			next if ($temp->[3]+$temp->[4]/2-$temp1->[3]-$temp1->[4]/2)*($temp->[7]+$temp->[8]/2-$temp1->[7]-$temp1->[8]/2)*$ts*$qs<0;
			##
			$insertion_flag=0;
			for(my $k=$temp->[13]+$ts;$k!=$temp1->[13];$k+=$ts){
				if($tsc_portions[$temp->[1]]->[$k][4]>-1 and $tsc_portions[$temp->[1]]->[$k][5]>0){
					$insertion_flag=1;
					last;
				}
			}
			for(my $k=$temp->[14]+$qs;$k!=$temp1->[14];$k+=$qs){
				if($qsc_portions[$temp->[5]]->[$k][4]>-1 and $tsc_portions[$temp->[5]]->[$k][5]>0){
					$insertion_flag=1;
					last;
				}
			}
			next if $insertion_flag>0;
			##
			for(my $k=$temp->[13]+$ts;$k!=$temp1->[13];$k+=$ts){
				if($tsc_portions[$temp->[1]]->[$k][4]<0 and $tsc_portions[$temp->[1]]->[$k][6]<0){
					$tsc_portions[$temp->[1]]->[$k][6]=0;
				}
			}
			for(my $k=$temp->[14]+$qs;$k!=$temp1->[14];$k+=$qs){
				if($qsc_portions[$temp->[5]]->[$k][4]<0 and $tsc_portions[$temp->[5]]->[$k][6]<0){
					$tsc_portions[$temp->[1]]->[$k][6]=0;
				}
			}						
		}
	}
	
	#### find out and store the begining nodes and ending nodes of all node-chains (paths)
	for(my $i=0;$i<scalar(@nodes);$i++){
		next if $nodes[$i]->[19]<0;
		next if $nodes[$i]->[11]>-1; #==-1 means the node is the head of a path; >-1 means the node is not the head
		my $j;
		for($j=$i;$nodes[$j]->[12]>-1;$j=$nodes[$j]->[12]){}
		push @begins,$i;	
		push @ends,$j;
	}
	print "There are ",scalar(@begins)," paths (with mirror) !\n";

	#### delete the mirrored scaffolds
	$temp=scalar(@begins);
	for(my $i=$temp-1;$i>0;$i--){
		for(my $j=$i-1;$j>=0;$j--){
			if( ( $nodes[$begins[$i]]->[21] == $nodes[$begins[$j]]->[21] 
						and $nodes[$ends[$i]]->[21] == $nodes[$ends[$j]]->[21]            )
					or ( $nodes[$begins[$i]]->[21] == $nodes[$ends[$j]]->[21] 
						   and $nodes[$ends[$i]]->[21] == $nodes[$begins[$j]]->[21] ) ){
				splice @begins,$i,1;
				splice @ends,$i,1;
				last;
			} 
		}
	}
	print "There are ",scalar(@begins)," paths (without mirror) !\n";		
	
	####
	for(my $i=0;$i<scalar(@begins);$i++){
		
		$node=$nodes[$begins[$i]];
		$node_count=0;
		my ($tsc_portion_id,$qsc_portion_id);
		
		############ processing the head info of a path, to select the longer overhang
		$sc=$node->[1]; ## target, from the begining to the node 
		if($node->[2]<0){
			$tlen=$tsc_ids[$sc]->[1];
			$tsc_portion_id=scalar(@{$tsc_portions[$sc]})-1;
			for(my $j=$node->[13]+1;$j<@{$tsc_portions[$sc]};$j++){
				if($tsc_portions[$sc]->[$j][6]<-5){
					$tlen=$tsc_portions[$sc]->[$j][2]+$tsc_portions[$sc]->[$j][3];
					$tsc_portion_id=$j;
					last;
				}
			}
			$tlen=$tlen-$node->[3]-$node->[4];
		}else{
			$tlen=0;
			$tsc_portion_id=0;
			for(my $j=$node->[13]-1;$j>=0;$j--){
				if($tsc_portions[$sc]->[$j][6]<-5){
					$tlen=$tsc_portions[$sc]->[$j][2];
					$tsc_portion_id=$j;
					last;
				}
			}
			$tlen=$node->[3]-$tlen;				
		}
			
		$sc=$node->[5]; ## query, from the begining to the node
		if($node->[6]<0){
			$qlen=$qsc_ids[$sc]->[1];
			$qsc_portion_id=scalar(@{$qsc_portions[$sc]})-1;
			for(my $j=$node->[14]+1;$j<@{$qsc_portions[$sc]};$j++){
				if($qsc_portions[$sc]->[$j][6]<-5){
					$qlen=$qsc_portions[$sc]->[$j][2]+$qsc_portions[$sc]->[$j][3];
					$qsc_portion_id=$j;
					last;
				}
			}
			$qlen=$qlen-$node->[7]-$node->[8];
		}else{
			$qlen=0;
			$qsc_portion_id=0;
			for(my $j=$node->[14]-1;$j>=0;$j--){
				if($qsc_portions[$sc]->[$j][6]<-5){
					$qlen=$qsc_portions[$sc]->[$j][2];
					$qsc_portion_id=$j;
					last;
				}
			}
			$qlen=$node->[7]-$qlen;				
		}
			
		### cutting
		if($tlen>=$qlen){
			$new_scaffolds[$i] = [1,   $node->[0],$node->[1],$node->[2],$tsc_portion_id,   undef,undef,undef,undef,   0,0,   $i, 1, undef];
			
			$temp =$tsc_portions[$node->[1]]->[$node->[13]-$node->[2]]; #$temp->[6] = $temp->[6] <-5 ? $temp->[6] : -5;
			$temp1=$qsc_portions[$node->[5]]->[$node->[14]-$node->[6]]; #$temp1->[6]= -6;
		}else{
			$new_scaffolds[$i] = [1,   $node->[0],$node->[5],$node->[6],$qsc_portion_id,   undef,undef,undef,undef,   0,0,   $i, 5, undef];
						
			$temp =$tsc_portions[$node->[1]]->[$node->[13]-$node->[2]]; #$temp->[6] = -6;
			$temp1=$qsc_portions[$node->[5]]->[$node->[14]-$node->[6]]; #$temp1->[6]= $temp1->[6]<-5 ? $temp1->[6] : -5;
		}	
		
		############ read through the path until end
		$temp1=0;
		$temp=$node->[0];
		$node_count=1;
		$nodes[$temp]->[23]=$i; ### mark the new_scaffold_id for nodes
		$nodes[$temp]->[24]=$temp1;
		$tsc_ids[$nodes[$temp]->[1]]->[4]=1; ### incorporated
		$tsc_ids[$nodes[$temp]->[5]]->[4]=1; ### incorporated	
		while($nodes[$temp]->[12]>-1){
			$temp1++;
			$temp=$nodes[$temp]->[12];
			$node_count++;
			$nodes[$temp]->[23]=$i; ### mark the new_scaffold_id for nodes
			$nodes[$temp]->[24]=$temp1;
			$tsc_ids[$nodes[$temp]->[1]]->[4]=1; ### incorporated
			$tsc_ids[$nodes[$temp]->[5]]->[4]=1; ### incorporated			
		}	
		$node=$nodes[$temp];			
		
		############ processing the tail info of a path, to select the longer overhang		
		$sc=$node->[1]; ## target
		if($node->[2]>0){
			$tlen=$tsc_ids[$sc]->[1];
			$tsc_portion_id=scalar(@{$tsc_portions[$sc]})-1;
			for(my $j=$node->[13]+1;$j<@{$tsc_portions[$sc]};$j++){
				if($tsc_portions[$sc]->[$j][6]<-5){
					$tlen=$tsc_portions[$sc]->[$j][2]+$tsc_portions[$sc]->[$j][3];
					$tsc_portion_id=$j;
					last;
				}
			}
			$tlen=$tlen-$node->[3]-$node->[4];
		}else{
			$tlen=0;
			$tsc_portion_id=0;
			for(my $j=$node->[13]-1;$j>=0;$j--){
				if($tsc_portions[$sc]->[$j][6]<-5){
					$tlen=$tsc_portions[$sc]->[$j][2];
					$tsc_portion_id=$j;
					last;
				}
			}
			$tlen=$node->[3]-$tlen;				
		}
			
		$sc=$node->[5]; ## query
		if($node->[6]>0){
			$qlen=$qsc_ids[$sc]->[1];
			$qsc_portion_id=scalar(@{$qsc_portions[$sc]})-1;
			for(my $j=$node->[14]+1;$j<@{$qsc_portions[$sc]};$j++){
				if($qsc_portions[$sc]->[$j][6]<-5){
					$qlen=$qsc_portions[$sc]->[$j][2]+$qsc_portions[$sc]->[$j][3];
					$qsc_portion_id=$j;
					last;
				}
			}
			$qlen=$qlen-$node->[7]-$node->[8];
		}else{
			$qlen=0;
			$qsc_portion_id=0;
			for(my $j=$node->[14]-1;$j>=0;$j--){
				if($qsc_portions[$sc]->[$j][6]<-5){
					$qlen=$qsc_portions[$sc]->[$j][2];
					$qsc_portion_id=$j;
					last;
				}
			}
			$qlen=$node->[7]-$qlen;				
		}
			
		### cutting
		if($tlen>=$qlen){
			$temp =$tsc_portions[$node->[1]]->[$node->[13]+$node->[2]]; #$temp->[6] = $temp->[6]<-5 ? $temp->[6] : -5;
			$temp1=$qsc_portions[$node->[5]]->[$node->[14]+$node->[6]]; #$temp1->[6]= -6;
			
			$new_scaffolds[$i]->[5] = $node->[0];
			$new_scaffolds[$i]->[6] = $node->[1];
			$new_scaffolds[$i]->[7] = $node->[2];
			$new_scaffolds[$i]->[8] = $tsc_portion_id;
			$new_scaffolds[$i]->[9] = $node_count;
			$new_scaffolds[$i]->[13] = 1;
		}else{
			$temp =$tsc_portions[$node->[1]]->[$node->[13]+$node->[2]]; #$temp->[6] = -6;
			$temp1=$qsc_portions[$node->[5]]->[$node->[14]+$node->[6]]; #$temp1->[6]= $temp1->[6]<-5 ? $temp1->[6] : -5;
			
			$new_scaffolds[$i]->[5] = $node->[0];
			$new_scaffolds[$i]->[6] = $node->[5];
			$new_scaffolds[$i]->[7] = $node->[6];
			$new_scaffolds[$i]->[8] = $qsc_portion_id;
			$new_scaffolds[$i]->[9] = $node_count;
			$new_scaffolds[$i]->[13] = 5;				
		}	
	}

	##verbose::: printing out @new_scaffolds, @nodes, @tsc/qsc_portions
	if($para{"--verbose"}>=2){
		$,="\t";

		print "\n##########This old_scaffold table was produced by path_terminal_extending. \n";
		print "#tsc_id\tscaffold_name\tsize\tstart_of_node_id\tend_of_node_id\tis_incorporated\n";
		for(my $i=0;$i<scalar(@tsc_ids);$i++){
			print $i,@{$tsc_ids[$i]},"\n";
		} 
		print "\n\n";
				
		print "\n##########This new_scaffold table was produced by path_terminal_extending. \n";
		print "#0:is_active\t1:start_node\t2:start_sc_id\t3:start_sc_strand\t4:start_portion_id\t5:end_node\t6:end_sc_id\t7:end_sc_strand\t8:end_portion_id\t9:node_count\t10:len\t11:new_scaffold_id\n";
		foreach $temp (@new_scaffolds){
			print @$temp,"\n";
		}
		print "\n\n";
		
		print "\n##########This new node table was produced by path_terminal_extending. \n";
		print "#tsc_name\tqsc_name\tnode_id\ttsc_id\tstrand\ttstart\ttlen\tqsc_id\tstrand\tqstart\tqlen\tscore\tali_len\tpredecessor\tsuccessor\ttsc_portion_ref\tqsc_portion_ref\ttsc_direction_predecessor\ttsc_direction_successor\tqsc_direction_predecessor\tqsc_direction_successor\tdeletion_visit_flag\tchain_id\tnet_id\tis_mirror\tnew_scaffold_id\torder_in_new_scaffolds\tNs_of_tsc\tlowcases_of_tsc\tNs_of_qsc\tlowcases_of_qsc\t*manual_deletion\n";
		for(my $i=0;$i<scalar(@nodes);$i++){
			print $tsc_ids[$nodes[$i]->[1]]->[0],$qsc_ids[$nodes[$i]->[5]]->[0],@{$nodes[$i]}[0 .. 29];
			print "\n";
		}				
		print "\n\n";
		
		print "\n##########This tsc_portions table was produced by path_terminal_extending. \n";
		print "#tsc_name\tportion_id\ttsc_id\tstart_position\tlen\tnode_id\tnode_status\tportion_status\tis_incorporated\n";
		for(my $i=0;$i<scalar(@tsc_portions);$i++){
			my $portion_count=scalar(@{$tsc_portions[$i]});
			my $portion_ref; 
			for(my $j=0;$j<$portion_count;$j++){
				$portion_ref = $tsc_portions[$i]->[$j];
				print $tsc_ids[$portion_ref->[1]]->[0],@{$portion_ref};
				print "\n";
			}
		}
		print "\n\n";	
			
		print "\n##########This qsc_portions table was produced by path_terminal_extending. \n";
		print "#qsc_name\tportion_id\ttsc_id\tstart_position\tlen\tnode_id\tnode_status\tportion_status\tis_incorporated\n";
		for(my $i=0;$i<scalar(@qsc_portions);$i++){
			my $portion_count=scalar(@{$qsc_portions[$i]});
			my $portion_ref; 
			for(my $j=0;$j<$portion_count;$j++){
				$portion_ref = $qsc_portions[$i]->[$j];
				print $qsc_ids[$portion_ref->[1]]->[0],@{$portion_ref};
				print "\n";
			}
		}
		print "\n\n";	
				
		$,=" ";
	}
}

#########################################
#
#########################################
sub new_scaffold_traversing(){
	
	my ($temp,$temp1,$temp2);
	my ($cstart, $csc,	$cstrand, $cportions, $cend, $clen, $cmid, $ctq); # current old_scaffold
	my ($nstart, $nsc,	$nstrand, $nportions, $nend, $nlen, $nmid, $ntq); # next old_scaffold
	my $is_the_last_portion; # end of a new_scaffold
	my ($xstart,$xend); # each output new_portions with no alignments or deleted alignments (non-node portions)
	my ($side, $connetion_flag); #flagging the target or query side; flagging the joining node of two old_scaffolds
	my ($score,$break);
	my ($tNs,$tLCs,$qNs,$qLCs,$tNLC_len,$qNLC_len);
	
	# $i=new_scaffold_id
	# sub_id=each uninterrupted old_scaffold, a new scaffold contains several uninterrupted old_scaffold portions
	# np_id=a portion of an uninterrupted old_scaffold, an uninterrupted old_scaffold contains
	# 	several portions, normally are either portions with or without alignments 
	my ($sub_id,$np_id);
	
	############### traversing every path
	for(my $i=0;$i<scalar(@new_scaffolds);$i++){

		$sub_id=-1;
		$is_the_last_portion=0;
		
		######## initiation of a traversing (the begin of a path)
		# $cstart,   $csc,	 $cstrand,  $cportions, *$cend, *$clen, *$cmid, $ctq
		# $nstart,  *$nsc,	*$nstrand, *$nportions,  $nend,  $nlen, ^$nmid, $ntq
		($cstart,$csc,$cstrand, $ctq)=($new_scaffolds[$i]->[4],$new_scaffolds[$i]->[2],$new_scaffolds[$i]->[3],$new_scaffolds[$i]->[12]);
		$cportions = $ctq == 1 ? $tsc_portions[$csc] : $qsc_portions[$csc];
		($cmid,$cend)=($cstart,$cstart);
		for(my $j=$cstart+$cstrand;;$j+=$cstrand){
			if($cportions->[$j][4]>-1 and $cportions->[$j][5]>=0) { $cend=$j; $temp=$nodes[$cportions->[$cend][4]]; }
			if($j==0 or $j==scalar(@$cportions)-1 or $cportions->[$j][6]<-5){ # loop breaking criteria
				if($j==$new_scaffolds[$i]->[8] and $csc==$new_scaffolds[$i]->[6]){ # the last portion
					$is_the_last_portion=1;
					$cend=$j;
				}else{ # if not the last portion, then this portion must be a node-portion
					$clen = $cstrand >0 ? $cportions->[$cend][2]+$cportions->[$cend][3]-$cportions->[$cstart][2] :
																$cportions->[$cstart][2]+$cportions->[$cstart][3]-$cportions->[$cend][2];
					$temp=$nodes[$cportions->[$cend][4]];
					$nmid= $ctq == 1 ? $temp->[14] : $temp->[13];
					($nstart,$nend)=($nmid,$nmid);
					$nsc = $ctq == 1 ? $temp->[5]  : $temp->[1];
					$nstrand= $ctq == 1 ? $temp->[6] : $temp->[2];
					$nportions= $ctq == 1 ? $qsc_portions[$nsc] : $tsc_portions[$nsc];
					$ntq = $ctq == 1 ? 5 : 1;
				}
				last;
			}
		}
		
		######## traversing, each time process the current old_scaffold portions
		while($is_the_last_portion<1){
			### look for nstart, cmid
			for(my $j=$nmid-$nstrand;;$j-=$nstrand){ # look for nstart
				$nstart=$j if $nportions->[$j][4]>-1 and $nportions->[$j][5]>=0;
				if($j==0 or $j==scalar(@$nportions)-1 or $nportions->[$j][6]<-5){
					$temp=$nodes[$nportions->[$nstart][4]];
					$cmid= $ctq == 1 ? $temp->[13] : $temp->[14];
					last;
				}
			}
			
			### look for nend, nlen
			for(my $j=$nmid+$nstrand;;$j+=$nstrand){
				$nend=$j if $nportions->[$j][4]>-1 and $nportions->[$j][5]>=0; 
				if($j==0 or $j==scalar(@$nportions)-1 or $nportions->[$j][6]<-5){
					if($j==$new_scaffolds[$i]->[8] and $nsc==$new_scaffolds[$i]->[6] and $ntq == $new_scaffolds[$i]->[13]){ # the last portion
						$is_the_last_portion=1;
						$nend=$j;
					}
					$nlen = $nstrand>0 ? $nportions->[$nend][2]+$nportions->[$nend][3]-$nportions->[$nstart][2] :
															 $nportions->[$nstart][2]+$nportions->[$nstart][3]-$nportions->[$nend][2];
					last;
				}
			}
			
			### output new_portions
			$np_id=-1; # set to 10000 instead -1 to allow room for adjustment 
			$sub_id++; 
			$cend  = $clen>=$nlen ? $cend : $cmid-$cstrand;
			$nstart= $clen>=$nlen ? $nmid+$nstrand : $nstart;
			if($cstrand>0){
				($xstart,$xend) = ($cportions->[$cstart][2],$cportions->[$cstart][2]);
			}else{
				($xstart,$xend) = ($cportions->[$cstart][2]+$cportions->[$cstart][3],$cportions->[$cstart][2]+$cportions->[$cstart][3]);
			}
			for(my $j=$cstart;$j!=$cend+$cstrand;$j+=$cstrand){
				$cportions->[$j][7]=1; # the portion has been incorporated
				if($cportions->[$j][4]<0 or $cportions->[$j][5]<0){
					if($cstrand>0){
						$xend=$cportions->[$j][2]+$cportions->[$j][3];
					}else{
						$xstart=$cportions->[$j][2];
					}
					# if $j points to the last portion of a path, then output the portion before getting out of the cycle
					if($j==$cend and $xend != $xstart){
						$np_id++;
						$new_portions[$i]->[$sub_id][$np_id] =  $ctq == 1 ? [$i,1,   $csc,$xstart,$xend,$cstrand,   0,0,0,0,   -2, 0, -1,-1,-1,-1] : [$i,2,   0,0,0,0,   $csc,$xstart,$xend,$cstrand,   -1, 0, -1,-1,-1,-1];
						$new_scaffolds[$i]->[10]+=$xend-$xstart; # new_scaffold length
					}					
				}else{
					# output non-node portions
					if($xend != $xstart){
						$np_id++;
						$new_portions[$i]->[$sub_id][$np_id] =  $ctq == 1 ? [$i,1,   $csc,$xstart,$xend,$cstrand,   0,0,0,0,   -2, 0, -1,-1,-1,-1] : [$i,2,   0,0,0,0,   $csc,$xstart,$xend,$cstrand,   -1, 0, -1,-1,-1,-1];
						$new_scaffolds[$i]->[10]+=$xend-$xstart; # new_scaffold length
					}
					# output node portions (node that two adjacent nodes may from a same pair of scaffolds, this need to be handled)
					$temp =$nodes[$cportions->[$j][4]];
					$temp1=$temp;
					$score=$score_origin[$temp1->[0]];
					($tNs,$tLCs,$qNs,$qLCs,$tNLC_len,$qNLC_len)= $temp1->[25]>-1 ? ($temp1->[25],$temp1->[26],$temp1->[27],$temp1->[28],$temp1->[4],$temp1->[8]) : (-1,-1,-1,-1,1,1); 
					$tsc_portions[$temp->[1]]->[$temp->[13]][7]=1;
					$qsc_portions[$temp->[5]]->[$temp->[14]][7]=1;
					$break=0;
					while(	$temp1->[12]>-1 and $nodes[$temp1->[12]]->[1] == $temp->[1] and  $nodes[$temp1->[12]]->[5] == $temp->[5] 
									and  $nodes[$temp1->[12]]->[6] == $temp->[6]  and  $nodes[$temp1->[12]]->[2] == $temp->[2]	){
						$temp2=$nodes[$temp1->[12]];
						my ($ts,$qs)=($temp->[2],$temp->[6]);
						last if ($temp->[3]+$temp->[4]/2-$temp2->[3]-$temp2->[4]/2)*($temp->[7]+$temp->[8]/2-$temp2->[7]-$temp2->[8]/2)*$ts*$qs<0;
						for(my $k=$temp1->[13]+$ts;$k!=$temp2->[13];$k+=$ts){ $break=1 if $tsc_portions[$temp->[1]]->[$k][6]<-5; }
						for(my $k=$temp1->[14]+$qs;$k!=$temp2->[14];$k+=$qs){ $break=1 if $qsc_portions[$temp->[5]]->[$k][6]<-5; }
						last if $break==1;					
						$temp1=$nodes[$temp1->[12]]; 
						$score+=$score_origin[$temp1->[0]];
						if($temp1->[25]>-1){
							$tNs+=$temp1->[25]; $qNs+=$temp1->[27];
							$tLCs+=$temp1->[26]; $qLCs+=$temp1->[28];
							$tNLC_len+=$temp1->[4]; $qNLC_len+=$temp1->[8];							
						}
					}
					if($temp->[0]!=$temp1->[0]){
						for(my $k=$temp->[13];$k!=$temp1->[13]+$temp->[2];$k+=$temp->[2]){ $tsc_portions[$temp->[1]]->[$k][7]=1; }
						for(my $k=$temp->[14];$k!=$temp1->[14]+$temp->[6];$k+=$temp->[6]){ $qsc_portions[$temp->[5]]->[$k][7]=1; }
					}
												
					$np_id++;
					if( $ctq == 1){
						$side=1; $connetion_flag = ($temp1->[13]==$cend or $temp->[13]==$cstart) ? 1 : 0;
					}else{
						$side=2; $connetion_flag = ($temp1->[14]==$cend or $temp->[14]==$cstart) ? 1 : 0;
					}
					if($temp->[2]>0 and $temp->[6]>0){
						$new_scaffolds[$i]->[10]+= $side==1 ? $temp1->[3]+$temp1->[4]-$temp->[3] : $temp1->[7]+$temp1->[8]-$temp->[7]; # new_scaffold length
						$new_portions[$i]->[$sub_id][$np_id]=[$i,$side,   $temp->[1],$temp->[3],$temp1->[3]+$temp1->[4],$temp->[2],   $temp->[5],$temp->[7],$temp1->[7]+$temp1->[8],$temp->[6],   $connetion_flag, $score, int(0.5+10000*$tNs/$tNLC_len)/100,int(0.5+10000*$tLCs/$tNLC_len)/100,int(0.5+10000*$qNs/$qNLC_len)/100,int(0.5+10000*$qLCs/$qNLC_len)/100];
					}elsif($temp->[2]>0 and $temp->[6]<0){
						$new_scaffolds[$i]->[10]+= $side==1 ? $temp1->[3]+$temp1->[4]-$temp->[3] : $temp->[7]+$temp->[8]-$temp1->[7]; # new_scaffold length
						$new_portions[$i]->[$sub_id][$np_id]=[$i,$side,   $temp->[1],$temp->[3],$temp1->[3]+$temp1->[4],$temp->[2],   $temp->[5],$temp1->[7],$temp->[7]+$temp->[8],$temp->[6],   $connetion_flag, $score, int(0.5+10000*$tNs/$tNLC_len)/100,int(0.5+10000*$tLCs/$tNLC_len)/100,int(0.5+10000*$qNs/$qNLC_len)/100,int(0.5+10000*$qLCs/$qNLC_len)/100];
					}elsif($temp->[2]<0 and $temp->[6]>0){
						$new_scaffolds[$i]->[10]+= $side==1 ? $temp->[3]+$temp->[4]-$temp1->[3] : $temp1->[7]+$temp1->[8]-$temp->[7]; # new_scaffold length
						$new_portions[$i]->[$sub_id][$np_id]=[$i,$side,   $temp->[1],$temp1->[3],$temp->[3]+$temp->[4],$temp->[2],   $temp->[5],$temp->[7],$temp1->[7]+$temp1->[8],$temp->[6],   $connetion_flag, $score, int(0.5+10000*$tNs/$tNLC_len)/100,int(0.5+10000*$tLCs/$tNLC_len)/100,int(0.5+10000*$qNs/$qNLC_len)/100,int(0.5+10000*$qLCs/$qNLC_len)/100];
					}else{
						$new_scaffolds[$i]->[10]+= $side==1 ? $temp->[3]+$temp->[4]-$temp1->[3] : $temp->[7]+$temp->[8]-$temp1->[7]; # new_scaffold length
						$new_portions[$i]->[$sub_id][$np_id]=[$i,$side,   $temp->[1],$temp1->[3],$temp->[3]+$temp->[4],$temp->[2],   $temp->[5],$temp1->[7],$temp->[7]+$temp->[8],$temp->[6],   $connetion_flag, $score, int(0.5+10000*$tNs/$tNLC_len)/100,int(0.5+10000*$tLCs/$tNLC_len)/100,int(0.5+10000*$qNs/$qNLC_len)/100,int(0.5+10000*$qLCs/$qNLC_len)/100];
					}																									 
					
					# set new xstart/xend for next run
					$j=  $ctq == 1 ? $temp1->[13] : $temp1->[14];
					if($cstrand>0){
						($xstart,$xend) = ($cportions->[$j][2]+$cportions->[$j][3],$cportions->[$j][2]+$cportions->[$j][3]);
					}else{
						($xstart,$xend) = ($cportions->[$j][2],$cportions->[$j][2]);
					}
				}
			}
			### in some cases, no portions of an old_scaffold have been output
			### this can be detect if $np_id still == 0, in these cases, $sub_id should be rolled back one step
			$sub_id-- if $np_id==-1; 
			
			### switch to the next old_scaffold
			($cstart, $csc,	$cstrand, $cportions, $cend, $clen, $cmid, $ctq) = ($nstart, $nsc,	$nstrand, $nportions, $nend, $nlen, $nmid, $ntq);
			if($cend==$new_scaffolds[$i]->[8] and $csc==$new_scaffolds[$i]->[6] and $ctq==$new_scaffolds[$i]->[13]){ # the last portion
				$is_the_last_portion=1;
			}else{ # not the last portion, and this portion should be node-portion
				$temp=$nodes[$cportions->[$cend][4]];
				$nmid= $ctq==1 ? $temp->[14] : $temp->[13];
				($nstart,$nend)=($nmid,$nmid);				
				$nsc = $ctq==1 ? $temp->[5]  : $temp->[1];
				$nstrand= $ctq==1 ? $temp->[6] : $temp->[2];
				$nportions= $ctq==1 ? $qsc_portions[$nsc] : $tsc_portions[$nsc];
				$ntq = $ctq==1 ? 5 : 1;
			}
		}

		######## processing the last portions
		$np_id=-1; # set to 10000 instead -1 to allow room for adjustment 
		$sub_id++; 
		if($cstrand>0){
			($xstart,$xend) = ($cportions->[$cstart][2],$cportions->[$cstart][2]);
		}else{
			($xstart,$xend) = ($cportions->[$cstart][2]+$cportions->[$cstart][3],$cportions->[$cstart][2]+$cportions->[$cstart][3]);
		}
		for(my $j=$cstart;$j!=$cend+$cstrand;$j+=$cstrand){
			$cportions->[$j][7]=1; # the portion has been incorporated
			if($cportions->[$j][4]<0 or $cportions->[$j][5]<0){
				if($cstrand>0){
					$xend=$cportions->[$j][2]+$cportions->[$j][3];
				}else{
					$xstart=$cportions->[$j][2];
				}
				if($j==$cend and $xend != $xstart){
					$np_id++;
					$new_portions[$i]->[$sub_id][$np_id] = $ctq==1 ? [$i,1,   $csc,$xstart,$xend,$cstrand,   0,0,0,0,   -2, 0, -1,-1,-1,-1] : [$i,2,   0,0,0,0,   $csc,$xstart,$xend,$cstrand,   -1, 0, -1,-1,-1,-1];
					$new_scaffolds[$i]->[10]+=$xend-$xstart; # new_scaffold length
				}					
			}else{
				# output non-node portions
				if($xend != $xstart){
					$np_id++;
					$new_portions[$i]->[$sub_id][$np_id] = $ctq==1 ? [$i,1,   $csc,$xstart,$xend,$cstrand,   0,0,0,0,   -2, 0, -1,-1,-1,-1] : [$i,2,   0,0,0,0,   $csc,$xstart,$xend,$cstrand,   -1, 0, -1,-1,-1,-1];
					$new_scaffolds[$i]->[10]+=$xend-$xstart; # new_scaffold length
				}
				# output node portions (node that two adjacent nodes may from a same pair of scaffolds, this need to be handled)
				$temp =$nodes[$cportions->[$j][4]];
				$temp1=$temp;
				$score=$score_origin[$temp1->[0]];
				($tNs,$tLCs,$qNs,$qLCs,$tNLC_len,$qNLC_len)= $temp1->[25]>-1 ? ($temp1->[25],$temp1->[26],$temp1->[27],$temp1->[28],$temp1->[4],$temp1->[8]) : (-1,-1,-1,-1,1,1);
				$tsc_portions[$temp->[1]]->[$temp->[13]][7]=1;
				$qsc_portions[$temp->[5]]->[$temp->[14]][7]=1;
				$break=0;
				while(	$temp1->[12]>-1 and $nodes[$temp1->[12]]->[1] == $temp->[1] and  $nodes[$temp1->[12]]->[5] == $temp->[5] 
								and  $nodes[$temp1->[12]]->[6] == $temp->[6]  and  $nodes[$temp1->[12]]->[2] == $temp->[2]	){
					$temp2=$nodes[$temp1->[12]];
					my ($ts,$qs)=($temp->[2],$temp->[6]);
					last if ($temp->[3]+$temp->[4]/2-$temp2->[3]-$temp2->[4]/2)*($temp->[7]+$temp->[8]/2-$temp2->[7]-$temp2->[8]/2)*$ts*$qs<0;
					for(my $k=$temp1->[13]+$ts;$k!=$temp2->[13];$k+=$ts){ $break=1 if $tsc_portions[$temp->[1]]->[$k][6]<-5; }
					for(my $k=$temp1->[14]+$qs;$k!=$temp2->[14];$k+=$qs){ $break=1 if $qsc_portions[$temp->[5]]->[$k][6]<-5; }
					last if $break==1;					
					$temp1=$nodes[$temp1->[12]]; 
					$score+=$score_origin[$temp1->[0]];
					if($temp1->[25]>-1){
						$tNs+=$temp1->[25]; $qNs+=$temp1->[27];
						$tLCs+=$temp1->[26]; $qLCs+=$temp1->[28];
						$tNLC_len+=$temp1->[4]; $qNLC_len+=$temp1->[8];							
					}
				}
				if($temp->[0]!=$temp1->[0]){
					for(my $k=$temp->[13];$k!=$temp1->[13]+$temp->[2];$k+=$temp->[2]){ $tsc_portions[$temp->[1]]->[$k][7]=1; }
					for(my $k=$temp->[14];$k!=$temp1->[14]+$temp->[6];$k+=$temp->[6]){ $qsc_portions[$temp->[5]]->[$k][7]=1; }
				}
											
				$np_id++;
				if($ctq==1){
					$side=1; $connetion_flag = ($temp1->[13]==$cend or $temp->[13]==$cstart) ? 1 : 0;
				}else{
					$side=2; $connetion_flag = ($temp1->[14]==$cend or $temp->[14]==$cstart) ? 1 : 0;
				}
				if($temp->[2]>0 and $temp->[6]>0){
					$new_scaffolds[$i]->[10]+= $side==1 ? $temp1->[3]+$temp1->[4]-$temp->[3] : $temp1->[7]+$temp1->[8]-$temp->[7]; # new_scaffold length
					$new_portions[$i]->[$sub_id][$np_id]=[$i,$side,   $temp->[1],$temp->[3],$temp1->[3]+$temp1->[4],$temp->[2],   $temp->[5],$temp->[7],$temp1->[7]+$temp1->[8],$temp->[6],   $connetion_flag, $score, int(0.5+10000*$tNs/$tNLC_len)/100,int(0.5+10000*$tLCs/$tNLC_len)/100,int(0.5+10000*$qNs/$qNLC_len)/100,int(0.5+10000*$qLCs/$qNLC_len)/100];
				}elsif($temp->[2]>0 and $temp->[6]<0){
					$new_scaffolds[$i]->[10]+= $side==1 ? $temp1->[3]+$temp1->[4]-$temp->[3] : $temp->[7]+$temp->[8]-$temp1->[7]; # new_scaffold length
					$new_portions[$i]->[$sub_id][$np_id]=[$i,$side,   $temp->[1],$temp->[3],$temp1->[3]+$temp1->[4],$temp->[2],   $temp->[5],$temp1->[7],$temp->[7]+$temp->[8],$temp->[6],   $connetion_flag, $score, int(0.5+10000*$tNs/$tNLC_len)/100,int(0.5+10000*$tLCs/$tNLC_len)/100,int(0.5+10000*$qNs/$qNLC_len)/100,int(0.5+10000*$qLCs/$qNLC_len)/100];
				}elsif($temp->[2]<0 and $temp->[6]>0){
					$new_scaffolds[$i]->[10]+= $side==1 ? $temp->[3]+$temp->[4]-$temp1->[3] : $temp1->[7]+$temp1->[8]-$temp->[7]; # new_scaffold length
					$new_portions[$i]->[$sub_id][$np_id]=[$i,$side,   $temp->[1],$temp1->[3],$temp->[3]+$temp->[4],$temp->[2],   $temp->[5],$temp->[7],$temp1->[7]+$temp1->[8],$temp->[6],   $connetion_flag, $score, int(0.5+10000*$tNs/$tNLC_len)/100,int(0.5+10000*$tLCs/$tNLC_len)/100,int(0.5+10000*$qNs/$qNLC_len)/100,int(0.5+10000*$qLCs/$qNLC_len)/100];
				}else{
					$new_scaffolds[$i]->[10]+= $side==1 ? $temp->[3]+$temp->[4]-$temp1->[3] : $temp->[7]+$temp->[8]-$temp1->[7]; # new_scaffold length
					$new_portions[$i]->[$sub_id][$np_id]=[$i,$side,   $temp->[1],$temp1->[3],$temp->[3]+$temp->[4],$temp->[2],   $temp->[5],$temp1->[7],$temp->[7]+$temp->[8],$temp->[6],   $connetion_flag, $score, int(0.5+10000*$tNs/$tNLC_len)/100,int(0.5+10000*$tLCs/$tNLC_len)/100,int(0.5+10000*$qNs/$qNLC_len)/100,int(0.5+10000*$qLCs/$qNLC_len)/100];
				}																								 
				
				# set new xstart/xend for next run
				$j= $ctq==1 ? $temp1->[13] : $temp1->[14];
				if($cstrand>0){
					($xstart,$xend) = ($cportions->[$j][2]+$cportions->[$j][3],$cportions->[$j][2]+$cportions->[$j][3]);
				}else{
					($xstart,$xend) = ($cportions->[$j][2],$cportions->[$j][2]);
				}
			}
		}		
	}

	## adjust the active portion, note that the ajustment does not update the new_scaffold len in hm.new_scaffolds 
	my @adjust;
	for(my $i=0;$i<scalar(@new_portions);$i++){
		for(my $j=0;$j<scalar(@{$new_portions[$i]});$j++){
			for(my $k=0;$k<scalar(@{$new_portions[$i]->[$j]});$k++){
				push @adjust,$new_portions[$i]->[$j][$k];
			}
		}
	}
	for(my $i=0;$i<scalar(@adjust)-1;$i++){ #when there two adjacent switching points
		if($adjust[$i]->[0]==$adjust[$i+1]->[0] 
				and $adjust[$i]->[10]==1 and $adjust[$i+1]->[10]==1 and $adjust[$i]->[1]!=$adjust[$i+1]->[1]){
			$adjust[$i]->[1]=$adjust[$i-1]->[1] if exists($adjust[$i-1]->[0]) and $adjust[$i]->[0]==$adjust[$i-1]->[0];
			$adjust[$i+1]->[1]=$adjust[$i+2]->[1] if exists($adjust[$i+2]->[0]) and $adjust[$i+1]->[0]==$adjust[$i+2]->[0];
		}
	}
	
	##verbose::: printing out @new_scaffolds, @nodes, @tsc/qsc_portions
	if($para{"--verbose"}>=1){
		$,="\t";

		print "\n##########This old_scaffold table was produced by new_scaffold_traversing. \n";
		print "#tsc_id\tscaffold_name\tsize\tstart_of_node_id\tend_of_node_id\tis_incorporated\n";
		for(my $i=0;$i<scalar(@tsc_ids);$i++){
			print $i,@{$tsc_ids[$i]},"\n";
		} 
		print "\n\n";
		
		print "\n##########This new_scaffold table was produced by new_scaffold_traversing. \n";
		print "#0:is_active\t1:start_node\t2:start_sc_id\t3:start_sc_strand\t4:start_portion_id\t5:end_node\t6:end_sc_id\t7:end_sc_strand\t8:end_portion_id\t9:node_count\t10:len\t11:new_scaffold_id\n";
		foreach $temp (@new_scaffolds){
			print @$temp,"\n";
		}
		print "\n\n";
		
		print "\n##########This new node table was produced by new_scaffold_traversing. \n";
		print "#tsc_name\tqsc_name\tnode_id\ttsc_id\tstrand\ttstart\ttlen\tqsc_id\tstrand\tqstart\tqlen\tscore\tali_len\tpredecessor\tsuccessor\ttsc_portion_ref\tqsc_portion_ref\ttsc_direction_predecessor\ttsc_direction_successor\tqsc_direction_predecessor\tqsc_direction_successor\tdeletion_visit_flag\tchain_id\tnet_id\tis_mirror\tnew_scaffold_id\torder_in_new_scaffolds\tNs_of_tsc\tlowcases_of_tsc\tNs_of_qsc\tlowcases_of_qsc\t*manual_deletion\n";
		for(my $i=0;$i<scalar(@nodes);$i++){
			print $tsc_ids[$nodes[$i]->[1]]->[0],$qsc_ids[$nodes[$i]->[5]]->[0],@{$nodes[$i]}[0 .. 29];
			print "\n";
		}				
		print "\n\n";
		
		print "\n##########This tsc_portions table was produced by new_scaffold_traversing. \n";
		print "#tsc_name\tportion_id\ttsc_id\tstart_position\tlen\tnode_id\tnode_status\tportion_status\tis_incorporated\n";
		for(my $i=0;$i<scalar(@tsc_portions);$i++){
			my $portion_count=scalar(@{$tsc_portions[$i]});
			my $portion_ref; 
			for(my $j=0;$j<$portion_count;$j++){
				$portion_ref = $tsc_portions[$i]->[$j];
				print $tsc_ids[$portion_ref->[1]]->[0],@{$portion_ref};
				print "\n";
			}
		}
		print "\n\n";	
			
		print "\n##########This qsc_portions table was produced by new_scaffold_traversing. \n";
		print "#qsc_name\tportion_id\ttsc_id\tstart_position\tlen\tnode_id\tnode_status\tportion_status\tis_incorporated\n";
		for(my $i=0;$i<scalar(@qsc_portions);$i++){
			my $portion_count=scalar(@{$qsc_portions[$i]});
			my $portion_ref; 
			for(my $j=0;$j<$portion_count;$j++){
				$portion_ref = $qsc_portions[$i]->[$j];
				print $qsc_ids[$portion_ref->[1]]->[0],@{$portion_ref};
				print "\n";
			}
		}
		print "\n\n";	
				
		$,=" ";
	}
}

#########################################
#
#########################################
#	## to find correct values for $node_t5/t3/q5/q3 and $score_t5/t3/q5/q3
#%np_extra=( 't53_len'=>-1, 'q53_len'=>-1,    't53_max_len'=>-1, 'q53_max_len'=>-1, 't53_raw_len'=>-1, 'q53_raw_len'=>-1,
#					  't5_len'=>-1,  't5_max_len'=>-1, 't5_switch'=>-1,'t5_raw_len'=>-1,
#					  't3_len'=>-1,  't3_max_len'=>-1, 't3_switch'=>-1,'t3_raw_len'=>-1,
#					  'q5_len'=>-1,  'q5_max_len'=>-1, 'q5_switch'=>-1,'q5_raw_len'=>-1,
#					  'q3_len'=>-1,  'q3_max_len'=>-1, 'q3_switch'=>-1,'q3_raw_len'=>-1 );
#########################################
## to find correct values for $node_t5/t3/q5/q3 and $score_t5/t3/q5/q3
#	%np=('is_visited'=>0, 'start_node'=>$nodes_by_score[$i]->[0], 'end_node'=>$nodes_by_score[$i]->[0], 
#	     'tsc_id'=>-1, 'qsc_id'=>-1, 'tsc_strand'=>1, 'qsc_strand'=>1, 
#			 't5'=>-1, 't5_score'=>0, 't5_strand'=>1, 
#			 't3'=>-1, 't3_score'=>0, 't3_strand'=>1, 
#			 'q5'=>-1, 'q5_score'=>0, 'q5_strand'=>1, 
#			 'q3'=>-1, 'q3_score'=>0, 'q3_strand'=>1 );
sub extra_statistics_of_nodes(){
	
	my ($temp,$temp1,$temp2);
	my ($adj,$direction);
	my ($node,$sc,$strand,$portions);
	my ($cnode,$csc,$cpos,$cstrand,$ctq);
	
	#### short-cut and solve the mirroring problem: 
	#### if the mirror node has been processed, reuse it
	$node=$nodes[$np{'start_node'}];
	if($npointers[$node->[0]]->[19]>1 or $npointers[$node->[0]]->[19]<0){
		@np_extra{'t53_len','t53_max_len','t53_raw_len',  't5_raw_len','t5_len','t5_max_len','t5_switch',  't3_raw_len','t3_len','t3_max_len','t3_switch',
							'q53_len','q53_max_len','q53_raw_len',  'q5_raw_len','q5_len','q5_max_len','q5_switch',  'q3_raw_len','q3_len','q3_max_len','q3_switch' }
						 =@np_extra{'q53_len','q53_max_len','q53_raw_len',  'q5_raw_len','q5_len','q5_max_len','q5_switch',  'q3_raw_len','q3_len','q3_max_len','q3_switch',
												't53_len','t53_max_len','t53_raw_len',  't5_raw_len','t5_len','t5_max_len','t5_switch',  't3_raw_len','t3_len','t3_max_len','t3_switch' };
		if($np{'qsc_strand'}<0){
			@np_extra{'t5_raw_len','t5_len','t5_max_len','t5_switch',  't3_raw_len','t3_len','t3_max_len','t3_switch',
							'q5_raw_len','q5_len','q5_max_len','q5_switch',  'q3_raw_len','q3_len','q3_max_len','q3_switch' }
						 =@np_extra{'t3_raw_len','t3_len','t3_max_len','t3_switch',  't5_raw_len','t5_len','t5_max_len','t5_switch',
						 						'q3_raw_len','q3_len','q3_max_len','q3_switch',  'q5_raw_len','q5_len','q5_max_len','q5_switch' };		
		}					
		return 2;
	}
	
	#### alignment_len	
	my $tsc_ali_len = $nodes[$np{'end_node'}]->[3]+$nodes[$np{'end_node'}]->[4]-$nodes[$np{'start_node'}]->[3];
	my $qsc_ali_len = $np{'qsc_strand'}>0 ?
										$nodes[$np{'end_node'}]->[7]+$nodes[$np{'end_node'}]->[8]-$nodes[$np{'start_node'}]->[7]
										: $nodes[$np{'start_node'}]->[7]+$nodes[$np{'start_node'}]->[8]-$nodes[$np{'end_node'}]->[7];
										
	#### raw len
	$np_extra{'t5_raw_len'}=$nodes[$np{'start_node'}]->[3];
	$np_extra{'t3_raw_len'}=$tsc_ids[$np{'tsc_id'}]->[1]-$nodes[$np{'end_node'}]->[3]-$nodes[$np{'end_node'}]->[4];
	$np_extra{'q5_raw_len'}=$np{'qsc_strand'}>0 ? $nodes[$np{'start_node'}]->[7] : $qsc_ids[$np{'qsc_id'}]->[1]-$nodes[$np{'start_node'}]->[7]-$nodes[$np{'start_node'}]->[8];
	$np_extra{'q3_raw_len'}=$np{'qsc_strand'}>0 ? $qsc_ids[$np{'qsc_id'}]->[1]-$nodes[$np{'end_node'}]->[7]-$nodes[$np{'end_node'}]->[8] : $nodes[$np{'end_node'}]->[7];
	$np_extra{'t53_raw_len'}=$tsc_ids[$np{'tsc_id'}]->[1];
	$np_extra{'q53_raw_len'}=$qsc_ids[$np{'qsc_id'}]->[1];										
	
	#### t/q/5/3 len
	for $adj (qw(t5 t3 q5 q3)){
		$sc        = ($adj eq 't5' or $adj eq 't3') ? $np{'tsc_id'} : $np{'qsc_id'};
		$node      = ($adj eq 't5' or $adj eq 'q5') ? $nodes[$np{'start_node'}] : $nodes[$np{'end_node'}];
		$portions  = ($adj eq 't5' or $adj eq 't3') ? $tsc_portions[$sc] : $qsc_portions[$sc];
		$direction = ($adj eq 't5' or $adj eq 'q5') ? -1*$np{$adj.'_strand'} : 1*$np{$adj.'_strand'};
		$temp      = ($adj eq 't5' or $adj eq 't3') ? 13 : 14;
		$temp1     = 0;
		for(my $i=$node->[$temp]+$direction;$i!=-1 and $i!=scalar(@$portions);$i+=$direction){
			$temp1+=$portions->[$i][3];
			last if $portions->[$i][6]<-5;
		}
 		$np_extra{$adj.'_len'} = $temp1;
	}
	
	#### t53/q53_len
	$np_extra{'t53_len'}=$np_extra{'t5_len'}+$np_extra{'t3_len'}+$tsc_ali_len;
	$np_extra{'q53_len'}=$np_extra{'q5_len'}+$np_extra{'q3_len'}+$qsc_ali_len;

=dd	

	#### note that for adjacent nodes have to be swtiched to the right places and right strands ####
	
	#### max_len/switch
	for $adj (qw(t5 t3 q5 q3)){
		
		if($np{$adj}<0){
			$np{$adj.'_max_len'} = $np{$adj.'_len'};
			$np{$adj.'_switch'}  = 0;
			next;			
		}		

		$direction = ($adj eq 't5' or $adj eq 'q5') ? 11 : 12;
		$temp1     = 0;
		$temp2     = 0;
		
		$cnode     = $nodes[$np{$adj}];
		$csc       = ($adj eq 't5' or $adj eq 't3') ? $np{'tsc_id'} : $np{'qsc_id'};
		$ctq			 = ($adj eq 't5' or $adj eq 't3') ? 1 : 5;
		$cstrand   = ($adj eq 't5' or $adj eq 't3') ? 1 : $np{'qsc_strand'};
		if($adj eq 't5'){
			$cpos = $nodes[$np{'start_node'}]->[3];
		}elsif($adj eq 't3'){
			$cpos = $nodes[$np{'end_node'}]->[3]+$nodes[$np{'end_node'}]->[4];
		}elsif($adj eq 'q5'){
			$cpos = $np{'qsc_strand'}>0 ? $nodes[$np{'start_node'}]->[7] : $nodes[$np{'start_node'}]->[7]+$nodes[$np{'start_node'}]->[8];
		}elsif($adj eq 'q3'){
			$cpos = $np{'qsc_strand'}>0 ? $nodes[$np{'end_node'}]->[7]+$nodes[$np{'end_node'}]->[8] : $nodes[$np{'end_node'}]->[7];
		}
		while($cnode->[$direction]>-1){
			$temp=$nodes[$cnode->[$direction]];
			if($temp->[$ctq]!=$csc){
				if($adj eq 't3' or $adj eq 'q3'){
					$temp1+= $cstrand>0 ? $cnode->[$ctq+2]+$cnode->[$ctq+3]-$cpos : $cpos-$cnode->[$ctq+2];
				}else{
					$temp1+= $cstrand>0 ? $cpos-$cnode->[$ctq+2] : $cnode->[$ctq+2]+$cnode->[$ctq+3]-$cpos;
				}
				$temp2++;
				$ctq = $ctq==1 ? 5 : 1;
				$csc = $cnode->[$ctq];
				$cstrand = $cnode->[$ctq+1];
				if($adj eq 't3' or $adj eq 'q3'){
					$cpos = $cstrand>0 ? $cnode->[$ctq+2]+$cnode->[$ctq+3] : $cnode->[$ctq+2];
				}else{
					$cpos = $cstrand>0 ? $cnode->[$ctq+2] : $cnode->[$ctq+2]+$cnode->[$ctq+3];
				}				
			}
			$cnode=$temp;	
		}
		$portions = $ctq==1 ? $tsc_portions[$csc] : $qsc_portions[$csc];
		$temp = $ctq==1 ? 13 : 14;
		$direction = ($adj eq 't5' or $adj eq 'q5') ? -1*$cstrand : 1*$cstrand;
		for(my $i=$cnode->[$temp]+$direction;$i!=-1 and $i!=scalar(@$portions);$i+=$direction){
			$temp1+=$portions->[$i][3];
			last if $portions->[$i][6]<-5;
		}
		$np_extra{$adj.'_max_len'} = $temp1;
		$np_extra{$adj.'_switch'}  = $temp2;
	}
	
	#### t53/q53_max_len
	$np_extra{'t53_max_len'}=$np_extra{'t5_max_len'}+$np_extra{'t3_max_len'}+$tsc_ali_len;
	$np_extra{'q53_max_len'}=$np_extra{'q5_max_len'}+$np_extra{'q3_max_len'}+$qsc_ali_len;
	
=cut
	
	return 1;	
}

#########################################
#
#########################################
# @new_scaffolds store each new scaffolds
# $new_scaffolds[ns_id]->[0:is_active, 1:start_node, 2:start_sc_id, 3:start_sc_strand, 4:start_portion_id,
#                                      5:end_node,   6:end_sc_id,   7:end_sc_strand,   8:end_portion_id,
#                         9:node_count, 10:len, 11:new_scaffold_id]
# @new_portions store each portion of new scaffolds
# $new_portions[new_scaffold_id]->[sub_id][np_id]->
#                        [0:new_scaffold_id, 1:selected_portion(1 or 2),
#                         2:sc_id, 3:start, 4:end, 5:strand, # portion 1
#                         6:sc_id, 7:start, 8:end, 9:strand  # portion 2 ]
sub output_new_scaffolds(){
	
	my $temp;
	
	$,="\t";
	
	if(-f "$out_dir/hm.new_scaffolds"){
		unlink "$out_dir/hm.new_scaffolds.bak";
		rename "$out_dir/hm.new_scaffolds","$out_dir/hm.new_scaffolds.bak";
	}
	
	@new_scaffolds_by_length = sort { $b->[10] <=> $a->[10] } @new_scaffolds;
	
	## calculate $raw_haplome size, $raw_haplome_scaffold_N50_size
	foreach $temp (@new_scaffolds){
		$raw_haplome_size += $temp->[10];
	}
	$temp=0;
	for(my $i=0;$i<scalar(@new_scaffolds_by_length);$i++){
		$temp+=$new_scaffolds_by_length[$i]->[10];
		if($temp>=0.5*$raw_haplome_size){
			$raw_haplome_scaffold_N50_number=$i+1;
			$raw_haplome_scaffold_N50_size=$new_scaffolds_by_length[$i]->[10];
			last;
		}
	}
	
	open(my $new_scaffoldsFH,">$out_dir/hm.new_scaffolds") or die "Can not create $out_dir/hm.new_scaffolds!\n";
	
	print $new_scaffoldsFH "# You may open this file in excel.\n"; 
	print $new_scaffoldsFH "# connection=-1/-2: not alignment portion\n"; #-1:the portion 1 is absent; -2 the portion 2 is absent
	print $new_scaffoldsFH "# connection=0: regular alignment portion\n";
	print $new_scaffoldsFH "# connection=1:  alignment portion can be used to join two scaffolds\n";
	print $new_scaffoldsFH "# You may manually change the value of two columns: *active_portion_manual and *connection_manual.\n";
	print $new_scaffoldsFH "# *active_portion_manual (overiding active_portion_updated):\n"; 
	print $new_scaffoldsFH "#    0   = no manual setting, \n";
	print $new_scaffoldsFH "#    1(2)= force to select the portion 1(2) which you want to include in the new assembly.\n";
	print $new_scaffoldsFH "# *connection_manual (overiding connection_updated): \n";
	print $new_scaffoldsFH "#    0    = no manual setting, \n";
	print $new_scaffoldsFH "#    1(-1)= force (not) to use the connection to join two scaffolds.\n\n";
	print $new_scaffoldsFH "# After editing or updating, this file may be saved as hm.new_scaffolds_edited or other names\n";
	print $new_scaffoldsFH "# in case being overwritten by another invocation of  HM_pathFinder.pl.\n\n";
	print $new_scaffoldsFH "# This table is created by using mis-join breaking mode $para{'--breakingMode'} .\n\n";
	print $new_scaffoldsFH "#scaffold_id\tscaffold_len\tsub_scaffold_id\tnew_portion_id\tactive_portion\t";
	print $new_scaffoldsFH "old_scaffold1_name\told_scaffold1_size\told_scaffold1_id\tstart1\tend1\tstrand1\tlen1\t";
	print $new_scaffoldsFH "old_scaffold2_name\told_scaffold1_size\told_scaffold2_id\tstart2\tend2\tstrand2\tlen2\t";
	print $new_scaffoldsFH "connection\tscore\tsc_Ns%\ttsc_LCs%\tqsc_Ns%\tqsc_LCs%\tactive_portion_updated\tconnection_updated\t*active_portion_manual\t*connection_manual\n";

	#### description.
	#### connection: -1/-2=not alignment portion, 0=regular alignment portion, 1=joining, 9(-9)=force (not) to use the connection
	#### connection_updated: 0=no updated, 1(-1)=force (not) to use the connetion (updated by gene model, BAC end sequencing, or experiment)  
	#### active_portion_updated: 0= no manual setting, 1=force to use portion 1, 2=force to use protion 2
	#### *active_portion_by_manual: 0= no manual setting, 1=force to use portion 1, 2=force to use protion 2, overiding active_portion_updated
	#### *connection_by_manual: 0= no manual setting, 1(-1)=force (not) to use the connection, overiding connection_updated
 
	for(my $i=0;$i<scalar(@new_scaffolds_by_length);$i++){
		my $sc=$new_scaffolds_by_length[$i];
		for(my $j=0;$j<scalar(@{$new_portions[$sc->[11]]});$j++){
			for(my $k=0;$k<scalar(@{$new_portions[$sc->[11]]->[$j]});$k++){
				my $subp=$new_portions[$sc->[11]]->[$j][$k];
				#
				print $new_scaffoldsFH $sc->[11],$sc->[10],$j,$k,$subp->[1];
				print $new_scaffoldsFH "\t";
				#
				if($subp->[10]==-1){
					print $new_scaffoldsFH 0,0,@$subp[2,3,4,5],$subp->[4]-$subp->[3];
				}else{
					print $new_scaffoldsFH $tsc_ids[$subp->[2]]->[0],$tsc_ids[$subp->[2]]->[1],@$subp[2,3,4,5],$subp->[4]-$subp->[3];
				}
				print $new_scaffoldsFH "\t";
				#
				if($subp->[10]==-2){
					print $new_scaffoldsFH 0,0,@$subp[6,7,8,9],$subp->[8]-$subp->[7],@$subp[10 .. 15],0,0,0,0;
				}else{
					print $new_scaffoldsFH $tsc_ids[$subp->[6]]->[0],$tsc_ids[$subp->[6]]->[1],@$subp[6,7,8,9],$subp->[8]-$subp->[7],@$subp[10 .. 15],0,0,0,0;					
				}
				#
				print $new_scaffoldsFH "\n";
			}
		}
	}
	close $new_scaffoldsFH;
	
	$,=" ";
}

#########################################
#
#########################################
#### assembly mis-joins
# @mis_joins[id]=[0:node_id, 1:ali_len, 2:ali_len_or_score, 3:terminal(5/3), 
#									4:tsc_name, 5:tsc_size, 	6:tsc_strand, 7:ali_start_of_tsc,  8:ali_end_of_tsc,  9:joining_point_of_tsc, 10:overhang_len_of_tsc,
#								 11:tsc_name,12:tsc_size,  13:qsc_strand,14:ali_start_of_qsc, 16:ali_end_of_qsc, 16:joining_point_of_qsc, 17:overhang_len_of_qsc,
#                18:*breakpoint_setting ] 
sub output_potential_assembly_error(){
	
	my $min_ali_len_or_score=int($para{'--misjoin_aliFilter'}/4);
	my $min_overhang_len=int($para{'--misjoin_overhangFilter'}/4);

	$,="\t";

	if(-f "$out_dir/hm.assembly_errors"){
		unlink "$out_dir/hm.assembly_errors.bak";
		rename "$out_dir/hm.assembly_errors","$out_dir/hm.assembly_errors.bak";
	}
	open(my $errorsFH,">$out_dir/hm.assembly_errors") or die "Can not create $out_dir/hm.assembly_errors!\n"; 
	
	print $errorsFH "# You may open this file in excel.\n"; 
	print $errorsFH "# This table shows the potential assembly errors (mis-joins).\n";
	print $errorsFH "# Nodes (alignment) with score or ali_len < $min_ali_len_or_score are not output.\n";
	print $errorsFH "# Sides with at least one overhang shorter than $min_overhang_len basepairs are not output.\n\n";
	print $errorsFH "# You may manually set the breakpoint in the *breakpoint_setting column:\n";
	print $errorsFH "#  0=no manual editing, \n";
	print $errorsFH "#  1=choose to break the joining point on the target scaffold (tsc), \n";
	print $errorsFH "#  2=choose to break the joining point on the query  scaffold (qsc).\n";
	print $errorsFH "#  3=choose to break both joining points on the target and query  scaffold (tsc/qsc).\n\n";	
	print $errorsFH "# After editing or updating, this file may be saved as hm.assembly_errors_edited or other names\n";
	print $errorsFH "# in case being overwritten by another invocation of  HM_pathFinder.pl.\n\n";
	
	if($scheme==10){
		print $errorsFH "# Column ali_len_or_score shows the alignment length.\n\n";
	}else{
		print $errorsFH "# Column ali_len_or_score shows the alignment score.\n\n";
	}
	
	print $errorsFH "#node_id\ttsc_ali_len\tali_len_or_score\tdirection(5or3)";
	print $errorsFH "\ttsc_name\ttsc_size\ttsc_strand\tali_start_of_tsc\tali_end_of_tsc\tjoining_point_of_tsc\toverhang_len_of_tsc";
	print $errorsFH "\tqsc_name\tqsc_size\tqsc_strand\tali_start_of_qsc\tali_end_of_qsc\tjoining_point_of_qsc\toverhang_len_of_qsc\t*tsc_breakpoint\t*qsc_breakpoint\t*breakpoint_setting\n";
	
	my ($joint, $node);
	for(my $i=0;$i<scalar(@mis_joins);$i++){
		$joint=$mis_joins[$i];
		next if $joint->[2]<$min_ali_len_or_score; #if the node addup ali_len smaller than 10000
		next if $joint->[10]<$min_overhang_len or $joint->[17]<$min_overhang_len;
		
		$node=$nodes[$joint->[0]];
		next if $node->[22]==1;
		
		print $errorsFH @$joint;
		print $errorsFH "\n";
	}
	
	$,="\t";
}

#########################################
#
######################################### 
sub output_unpaired_portions(){
	
	my ($tp,$qp); # temp for $tsc/qsc_portions
	my @sctmp; # ->[start,len], store each unpaired portions of a scaffold
	my $part_len_limit=1; #only output the unpaired portions which long than 2000 bp 
	#my $full_len_limit=0.05; # only output those scaffold containing >0.1 unpaired sequence
	my ($total, $start, $end);	
	
	#### $unincorps[id]->[0:scaffold_name, 1:size, 2:start, 3:len, 4:full/part ]
	my @unincorps;
	
	#### store full unpaired scaffolds
	for(my $i=0;$i<scalar(@tsc_ids);$i++){
		next if $tsc_ids[$i]->[4]>0;
		push @unincorps,[$tsc_ids[$i]->[0],$tsc_ids[$i]->[1],0,$tsc_ids[$i]->[1],'full'];
	}
	
	#### map unpaired portions onto @tsc_portions and output them
	for(my $i=0;$i<scalar(@tsc_ids);$i++){
		next if $tsc_ids[$i]->[4]<1;
		$tp=$tsc_portions[$i];
		$qp=$qsc_portions[$i];
		## mapping
		for(my $j=0;$j<scalar(@$tp);$j++){
			$tp->[$j][7]=1 if $qp->[$j][7]==1;
		}
		## calculate total unpaired length
		## those portions shorter than part_len_limit(default is 2000bp) were discarded
		@sctmp=();
		($total,$start,$end)=(0,0,0);
		for(my $j=0;$j<scalar(@$tp);$j++){
			if($tp->[$j][7]==1){
				$end=$tp->[$j][2];
				if(($end-$start)>=$part_len_limit){
					$total+=$end-$start;
					push @sctmp,[$start,$end-$start];
				}
				($start,$end)=($tp->[$j][2]+$tp->[$j][3], $tp->[$j][2]+$tp->[$j][3]);
			}
		}
		$end=$tsc_ids[$i]->[1];
		if(($end-$start)>=$part_len_limit){
			$total+=$end-$start;
			push @sctmp,[$start,$end-$start];
		}		
		## only those unpaired portions longer than 5% total scaffold lenght were output
		for(my $j=0;$j<scalar(@sctmp);$j++){
		#	next if $sctmp[$j]->[1]<$tsc_ids[$i]->[1]*$full_len_limit;
			push @unincorps,[$tsc_ids[$i]->[0],$tsc_ids[$i]->[1],$sctmp[$j]->[0],$sctmp[$j]->[1],'part'];
		}
	}
	
	#### calculate the sequence size
	foreach my $temp (@unincorps){
		$raw_size_of_unpaired_scaffolds += $temp->[3] if $temp->[4] eq 'full';
		$raw_size_of_unpaired_scaffold_portions += $temp->[3] if $temp->[4] eq 'part';
	}
	
	#### printing out the unpaired portions
	$,="\t";
	if(-f "$out_dir/hm.unpaired"){
		unlink "$out_dir/hm.unpaired.bak";
		rename "$out_dir/hm.unpaired","$out_dir/hm.unpaired.bak";
	}	
	@unincorps = sort { $a->[4] cmp $b->[4] or $b->[3] <=> $a->[3] } @unincorps;
	open(my $unFH,">$out_dir/hm.unpaired") or die "Can not open out_dir/hm.unpaired !\n";
	print $unFH "# You may open this file in excel.\n";
	print $unFH "# This table contains scaffolds and scaffold portions that failed to be incorporated\n";
	print $unFH "# into the new scaffold assebmly in the path_finding process.\n";
	print $unFH "# These sequence may be used for further evaluation to see if they could be incorporated.\n";
	#print $unFH "# Note that only scaffold portions longer than 5% of full scaffold length were output, \n";
	#print $unFH "# and only sequence portions of at least 1 bp were output. \n\n";
	print $unFH "# This file is not intended to be manually modified. \n\n";
	print $unFH "#scaffold_name\tsize\tstart\tlen\tfull_scaffold_or_part_of_the_scaffold\n";
	for(my $i=0;$i<scalar(@unincorps);$i++){
		my $un=$unincorps[$i];
		print $unFH @$un,"\n";
	}
	
}

